# Java面试的一些题目



## Java基础

### 一.基本数据类型

#### 1.continue、break 和 return 的区别是什么？

continue 是跳出一次循环，接着下一次循环
break是跳出整个循环
return是返回一个参数值 或者提前结束循环

#### 2.Java 中的几种基本数据类型了解么？

整型：
byte   1
short  2
int    4
long   8

浮点型：
float  4
double 8

字符型：
char   2

布尔型：
boolean 1

#### 3.基本类型和包装类型的区别？

拆封箱的操作，包装类型有很多附加的方法，比基本类型使用更方便，可以进行更复杂的操作

#### 4.包装类型的缓存机制了解么？

很多包装类型都是把一些值直接缓存起来，加快速度，比如Boolean、还有Integer都是直接从缓存中取一部分值，如何大于缓存中，那么就会重新new一个对象

#### 5.自动装箱与拆箱了解吗？原理是什么？

基本类型和包装类型的转换
原理是：
**装箱会调用valueOf()**
**拆箱会调用xxxValue()方法**

#### 6.为什么浮点数运算的时候会有精度丢失的风险？

这个跟对应的机器的二进制有关系还有32位和64位存储有关系，因为有永远除不尽的数据需要保存，那么就需要截断数据 就会出现精度无拆问题

#### 7.如何解决浮点数运算的精度丢失问题？

使用BigDecimal类型来处理高精度的数据，例如和钱相关的

#### 8.超过 long 整型的数据应该如何表示？

使用BigInteger来表示 专门用来处理超过int和long的范围的时候 数据处理

#### 9.BigDecimal详解

方法的使用加减乘除，已经对数据的处理 向上取整，向下取整等
还有两个数据比较实用compareTo来比较
其实建议使用new BigDecimal(new String())来初始化一个，防止double的精度丢失问题

### 二.变量

#### 1.成员变量与局部变量的区别？

作用范围：成员变量是作用类的，局部变量的作用域是所在的方法里面
初始值：成员变量在类加载的的时候会初始化该类型的初始值（如果没有初始值，那么就会随意指向其他的内存地址，那么就会错乱），而局部变量不会这样操作
生命周期：成员变量的生命周期是跟类的生命周期一样，而局部变量是方法结束即消亡

#### 2.静态变量有什么作用？

静态变量创建就就一份，在类加载的时候就把数据存储到内存里面（只会创建一次），然后所有需要用到这个变量的，都可以直接使用ClassName.StaticName获取值

#### 3.字符型常量和字符串常量的区别?

字符串常量是一个内存地址值（String底层是一个数组），字符串常量池是JVM单独创建出来的一部分空间存储字符串常量的，如果字符串常量在内存有，那么就直接取出来用，如果没有，那么就会new String出来，并且保存一份到字符串常量池里面
字符型常量：单引号引用到char字符，占两个字节

### 三.方法

#### 1.什么是方法的返回值?方法有哪几种类型？

返回值：调用这个方法获取的结果
类型：无返回值有参数，无返回值无参数，有返回值有参数，有返回值无参数

#### 2.静态方法为什么不能调用非静态成员?

非晶态成员需要在对象初始化的是才会创建，但是静态方法在类加载的时候就会创建，所以静态方法拿不到没创建的成员信息

#### 3.静态方法和实例方法有何不同？

使用方法：静态方法可以直接使用ClassName.MethodName() 调用，而实例方法
创建时期：静态方法是类加载的是创建的，但是实例方法是在new的时候创建的的

#### 4.重载和重写有什么区别？

重载：是相同的方法名，不同的参数 例如一个String的方法有多个重载的方法
重写：重写一般是子类去重写父类的方法，重写的的返回类型应该小于等于父类的，异常类型也应该小于等于父类的异常

#### 5.什么是可变长参数？

method(args ....) 可以使用多个参数 然后底层是一个数组存储这些数据

### 四.面向对象基础

#### 1.面向对象和面向过程的区别

面向对象：使用的对象的方法来处理
面向过程：是把整个事情一部分分隔开，然后一个个执行 

#### 2.创建一个对象用什么运算符?对象实体与对象引用有何不同?

使用new 来创建一个对象 
对象引用指向内存地址

#### 3.对象的相等和引用相等的区别

对象相等是对象的值相等
引用相等是等内存地址是不是相等

#### 4.如果一个类没有声明构造方法，该程序能正确执行吗?

可以正确执行，因为创建的时候，默认创建了构造方法，可以隐性创建

#### 5.构造方法有哪些特点？是否可被 override?

构造方法不能被override，可以被重载
特点：可以有多个参数，没有返回值，无需调用

#### 6.面向对象三大特征

继承：只能继承一个父类，拥有父类的方法和属性（包括私有的），但是不能使用私有的
封装：类似空调，不需要了解里面有什么东西，只需要告诉遥控器，按什么就会输出什么就可以了
多态：一个方法的多个实现，最终是谁实现，运行的时候才知道   SonService service = new Service（）;
多态是指同一类型的对象，在不同的情况下表现出不同的行为。多态允许我们使用父类的引用指向子类的对象；多态通过方法的重写实现。

#### 7.接口和抽象类有什么共同点和区别？

继承：接口可以多继承；抽象类只能单即成
都不能被实例化、都可以包含抽象方法、都有default默认方法
常量：接口常量必须赋初始值，抽象类默认default

#### 8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

深拷贝：复制一个完整的内容，递归复制，有不同的内存地址，相互不影响
浅拷贝：只拷贝内存地址，修改另外拷贝的值，原有数据也会改变，用于基础类型或者不可变引用对象
引用拷贝：特殊的浅拷贝，只负责对象的引用；引用拷贝通常用于传递对象作为参数，以避免复制整个对象。

#### 9.Java值传递详解

java只能值传递，基础类型传递的是直接的值，引用类型传递的是内存地址

#### 10.Java魔法类Unsafe详解

是native修饰的方法，用来操作底层操作系统的内存、内存屏障等各种操作

### 五.Object

#### 1.Object 类的常见方法有哪些？

euqals()、clone（）、wait（）、getClass、hashCode  、toString、notify、notifyAll、

#### 2.== 和 equals() 的区别

基础类型，==是比较两个数据的内容，引用类型==是比较两个对象的内存地址是不是相等
equals是比较两个值是不是相等,但是大部分的对象里面建议重写equals()都被重写了,默认也是比较内存地址

#### 3.hashCode() 有什么用？

hashCode是每个对象都有的（通过对象的内容计算出来的），用于快速查找和区分对象
哈希表使用哈希码作为索引，从而实现高效的数据存储和检索。
如果两个对象的哈希码相同，哈希表会使用其他方法（例如 equals()）来区分它们。

#### 4.为什么要有 hashCode？

方便查找对象和数据，方便比较对象是否相等

#### 5.为什么重写 equals() 时必须重写 hashCode() 方法？

因为hashcode一样（hash碰撞💥），不一定两个对象相等，两个相等的第二个条件是equals也相等
如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。

### 六.String

#### 1.String、StringBuffer、StringBuilder 的区别？

线程安全：String线程安全 final 修饰，StringBuffer 线程安全 使用了synchronize修饰，StringBuilder线程不安全
性能：少量数据就String，大量数据 多线程就StringBuffer、单线程就是StringBuilder
String每次改变的时候都会创建一个新class
StringBuffer、StringBuilder：可变对象，每次都是操作原对象

#### 2.String 为什么是不可变的?

final修饰的

#### 3.字符串拼接用“+” 还是 StringBuilder?

+：每次都会创建一个新的对象，少量数据使用
StringBuilder使用append，大量数据使用

#### 4.String#equals() 和 Object#equals() 有何区别？

String的equals重写了的，比较值
Object的equals是比较对象的引用地址内存地址

#### 5.字符串常量池的作用了解吗？

jvm单独开辟的一块空间出来存放字符串常量池，如果没有，那么new一个对象到放到字符串常量池里面，存在就返回引用地址
节省内存空间

#### 6.String s1 = new String("abc");这句话创建了几个字符串对象？

如果abc在常量池不存在 那么创建两个对象，第一次创建对象放到内存中，第二次创建对象，把常量池中的引用过来
存在，那么就创建一次

#### 7.String#intern 方法有什么作用?

把字符串放到常量池里面，并返回引用

#### 8.String 类型的变量和常量做“+”运算时发生了什么？

常量是做了拼接，变量也是 内部使用了StringBuilder 然后toString 是一个新对象
引用的值在程序编译期是无法确定的，编译器无法对其进行优化。 
如果加了final修饰的string，那么在编译的时候就是常量相加了，不涉及到new新对象

### 七.异常

#### 1.Exception 和 Error 有什么区别？

Exception 是可以捕获到的
Error是无法捕获到的-比如OOM这种整个崩了

#### 2.Checked Exception 和 Unchecked Exception 有什么区别？

checked在代码编译过程中，如果有，那么就无法编译成功
unchecked的就算可能有问题，编译没啥问题，在执行到这段代码的时候就崩了

#### 3.Throwable 类常用方法有哪些？

getMessage、printStackinfo，toString、getLocalizedMessage

#### 4.try-catch-finally 如何使用？

不要在finally里面写返回值

#### 5.finally 中的代码一定会执行吗？

不一定，因为假设执行到一半，程序停了 啥都没有了

#### 6.如何使用 try-with-resources 代替try-catch-finally？

twr主要是为了做io流到关闭，程序会自动帮我关闭流，实现了AutoCloseable

#### 7.异常使用有哪些需要注意的地方？

exception打印了就不要抛出去了 要手动处理



### 八.泛型

#### 1.什么是泛型？有什么作用？

规范代码，增加通用性

#### 2.泛型的使用方式有哪几种？

泛型类 类似通用返回
泛型接口： 动态的对象 可以根据泛型动态返回
泛型方法：动态的对象 可以根据泛型动态返回

#### 3.项目中哪里用到了泛型？

Result类中使用了T 作为通用的返回对象

#### 4.通配符详解

T、E、等等



### 九.反射

#### 1.何谓反射？

反射 通过name或者class 拿到这个对象，然后获取到这个类的方法、属性 然后反向调用这个方法。
在框架中用的比较多

#### 2.反射的优缺点？

优：方便灵活
缺：跳过了很多的安全检查

#### 3.反射的应用场景？

AOP中的就用了动态代理（依赖反射）

### 十.注解

#### 1.何谓注解？

主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解本质是一个继承了Annotation 的特殊接口

#### 2.注解的解析方法有哪几种？

编译器直接扫描
运行的时候 通过反射操作

### 十一.SPI

#### 1.何谓 SPI?

service provide interface 
就是java定义一个接口，然后其他人自己实现自己的，然后再Application ClassLoader加载的时候 
会去扫面meta-info/service这个文件夹下 找到对应的class的全路径，然后扫描使用ServiceLoader加载进来

#### 2.SPI 和 API 有什么区别？

api是接口直接提供给别人获取结果
SPI 是提供接口给别人 让其实现自己要实现的功能

#### 3.SPI 的优缺点？

优：可以在Application classLoader加载的时候 把我们需要加载的class加载进去，跳过了双亲委派机制
缺：需要循环遍历查找 性能低，可以忽略

### 十二.序列化和反序列化

#### 1.什么是序列化?什么是反序列化?

文件数据传输的时候 需要序列化 转成字节流
接收数据的时候 需要反序列化 转成字符号

#### 2.如果有些字段不想进行序列化怎么办？

使用transient 修饰

#### 3.常见序列化协议有哪些？

jdk自带的、Kryo、json、xml

#### 4.为什么不推荐使用 JDK 自带的序列化？

不支持跨语言，性能差

### 十三.IO TODO

#### 1.Java IO 流了解吗？

字节（输入/输出流）流
字符（输入/输出流）流

#### 2.I/O 流为什么要分为字节流和字符流呢?

#### 3.Java IO 中的设计模式有哪些？

#### 4.BIO、NIO 和 AIO 的区别？



### 十四.语法糖

#### 1.什么是语法糖？

简化操作，方便阅读

#### 2.Java 中有哪些常见的语法糖？

增强for、泛型、拆箱装箱、trywith resource、lambda



### 十五.集合

#### 1.说说 List, Set, Queue, Map 四者的区别？集合框架底层数据结构总结？

- List 有顺序且不唯一 底层是数组
      LinkedList：使用了链表
      Vector：数组
      ArrayList：底层是数组

- Set 无序且唯一 底层是hashMap 基本上都用了hashMap的方法，put方法的时候 先去调用map的put方法判断下数据是否存在，如果有就插入数据失败，否则成功
      HashSet：底层用HashMap
      LinkedHashSet：底层用LinkedHashMap
      TreeSet：底层红黑树 （有序、唯一）
- Queue 先进先出 有序可重复
      PriorityQueue: 最小堆
      DelayQueue： 延迟队列
      Dqueue：双向队列
      BlockingQueue：阻塞队列

- Map 一对一 ，key,value都可以null
      HashMap：数组加链表 链表主要是为了解决hash冲突，当链表长度大于8，就会考虑转化为红黑树（转化的时候会判断数组的长度有没有大于64，小于64就会先扩容）
      LinkedHashMap：数组加双向链表和红黑树，实现了访问顺序
      HashTable：不再使用了，数组加链表，链表为了解决hash冲突
      TreeSet：红黑树，自平衡的二叉树

### 3.如何选用集合?

- Map：线程安全用ConcurrentHashMap，非线程安全使用hashmap
- Set：看是否有序，有序就TreeSet，其他的就hashSet
- List：线程安全用Vector，线程不安全使用ArrayList

### 5.List

#### 5.1.ArrayList 和 Array（数组）的区别？

Array：普通的数组（静态）
ArrayList： 底层是数组，但是多了很多方法，动态扩容，可以存储对象，基本类型需要装箱

#### 5.2.ArrayList 可以添加 null 值吗？

可以

#### 5.3.ArrayList 插入和删除元素的时间复杂度？

如何删除第一个元素 那么就是n，因为所有的元素都要往前移动，如果删除最后1个元素 那么就是1，指定位置n/2
插入尾部的话是1，指定位置的n/2 ,如果要扩容 也是n

#### 5.4.LinkedList 插入和删除元素的时间复杂度？

指定位置是n/2
其他的位置（首位） 都是n ，改动链表指向

#### 5.5.LinkedList 为什么不能实现 RandomAccess 接口？

LinkedList是双向链表，没有固定的内存空间，不支持随机访问

#### 5.6.ArrayList 与 LinkedList 区别?

线程安全：都是不安全的
底层结构：ArrayList是数组，LinkedList是链表
内存空间：A是连续的，l花费的空间比a多，链表信息要保存
支持快速范围：a可以，l不行

#### 5.7.说一说 ArrayList 的扩容机制吧

初始值是10，当判断容量不够的时候，就根据增长因子（默认1.5）会扩容1.5倍
会先创建一个大数组，然后copy数据过去

### 6.Set

#### 6.1.Comparable 和 Comparator 的区别

Comparable 接口用于自然排序，即对象本身具有默认的排序顺序。
Comparator 接口用于外部比较，允许我们在不修改原始类的情况下定义不同的比较规则。

#### 6.2.无序性和不可重复性的含义是什么

无序性：没有固定的顺序
不可重复性：每个值都是唯一的

#### 6.3.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

线程安全：都是线程不安全的
顺序性：TreeSet是顺序的
底层结构：HashSet是hashmap、LinkedHashSet是LinkedHashMap、TreeSet是红黑树

### 7.Queue

#### 7.1.Queue 与 Deque 的区别

Q是单向队列，D是双向队列

#### 7.2.ArrayDeque 与 LinkedList 的区别



#### 7.3.说一说 PriorityQueue

元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。
利用了二叉堆的数据结构来实现的，默认是小顶堆底层使用可变长的数组来存储数据
线程非安全

#### 7.4.什么是 BlockingQueue？

ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。
ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。
ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

#### 7.5.BlockingQueue 的实现类有哪些？

是一个接口，继承自 Queue。BlockingQueue阻塞的原因是：其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。

#### 7.6.ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？



### 8.Map

#### 8-1.HashMap 和 Hashtable 的区别

线程安全：map不安全。table是线程安全的
性能：map的更好更快，table的慢一些（淘汰）
null支持：map都支持key。value ；table不支持

#### 8-2.HashMap 和 HashSet 区别

HashSet底层就是hashMap
存储的数据不一样，一个是keyvalue，一个是value值 
重复值的问题，map值可以重复，set不得行

#### 8-3.HashMap 和 TreeMap 区别

treeMap key会排序，集合内元素的搜集

#### 8-4.HashSet 如何检查重复?

去调用hashmap的put方法 ，判断有没有值，然后判断插入成功还是失败

#### 8-5.HashMap 的底层实现

底层是数组➕链表+红黑树，如果出现了hash冲突，那么就会把数据放到链表里面，
当链表长度大于8，就会考虑转化为红黑树（转化的时候会判断数组的长度有没有大于64，小于64就会先扩容）

#### 8-6.HashMap 的长度为什么是 2 的幂次方

为了减少hash碰撞

#### 8-7.HashMap 多线程操作导致死循环问题

1.8之前，因为扩容会出现该问题
1.8之后优化的了操作，不会再出现，但是1.8之后出现了多线程 put的问题

#### 8-8.HashMap 为什么线程不安全？

可能出现多个线程同时操作，进行put

#### 8-9.HashMap 常见的遍历方式?

keyset，entry等

#### 8-10.ConcurrentHashMap 和 Hashtable 的区别

线程安全：都是线程安全的 ，table使用了synchronize，而concurrentHashMap使用了数组链表加红黑树了，

#### 8-11.ConcurrentHashMap 线程安全的具体实现方式/底层具体实现 TODO





#### 8-12.JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？

1.7 是使用segement（node+cas+synchronize）
1.8 使用 数组链表+红黑树

#### 8-13.ConcurrentHashMap 为什么 key 和 value 不能为 null？

为了避免二义性

#### 8-14.ConcurrentHashMap 能保证复合操作的原子性吗？

有原子操作的方法可以实现





