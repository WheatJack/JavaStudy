# Java面试的一些题目



## Java基础

### 一.基本数据类型

#### 1.continue、break 和 return 的区别是什么？

continue 是跳出一次循环，接着下一次循环
break是跳出整个循环
return是返回一个参数值 或者提前结束循环

#### 2.Java 中的几种基本数据类型了解么？

整型：
byte   1
short  2
int    4
long   8

浮点型：
float  4
double 8

字符型：
char   2

布尔型：
boolean 1

#### 3.基本类型和包装类型的区别？

拆封箱的操作，包装类型有很多附加的方法，比基本类型使用更方便，可以进行更复杂的操作

#### 4.包装类型的缓存机制了解么？

很多包装类型都是把一些值直接缓存起来，加快速度，比如Boolean、还有Integer都是直接从缓存中取一部分值，如何大于缓存中，那么就会重新new一个对象

#### 5.自动装箱与拆箱了解吗？原理是什么？

基本类型和包装类型的转换
原理是：
**装箱会调用valueOf()**
**拆箱会调用xxxValue()方法**

#### 6.为什么浮点数运算的时候会有精度丢失的风险？

这个跟对应的机器的二进制有关系还有32位和64位存储有关系，因为有永远除不尽的数据需要保存，那么就需要截断数据 就会出现精度无拆问题

#### 7.如何解决浮点数运算的精度丢失问题？

使用BigDecimal类型来处理高精度的数据，例如和钱相关的

#### 8.超过 long 整型的数据应该如何表示？

使用BigInteger来表示 专门用来处理超过int和long的范围的时候 数据处理

#### 9.BigDecimal详解

方法的使用加减乘除，已经对数据的处理 向上取整，向下取整等
还有两个数据比较实用compareTo来比较
其实建议使用new BigDecimal(new String())来初始化一个，防止double的精度丢失问题

### 二.变量

#### 1.成员变量与局部变量的区别？

作用范围：成员变量是作用类的，局部变量的作用域是所在的方法里面
初始值：成员变量在类加载的的时候会初始化该类型的初始值（如果没有初始值，那么就会随意指向其他的内存地址，那么就会错乱），而局部变量不会这样操作
生命周期：成员变量的生命周期是跟类的生命周期一样，而局部变量是方法结束即消亡

#### 2.静态变量有什么作用？

静态变量创建就就一份，在类加载的时候就把数据存储到内存里面（只会创建一次），然后所有需要用到这个变量的，都可以直接使用ClassName.StaticName获取值

#### 3.字符型常量和字符串常量的区别?

字符串常量是一个内存地址值（String底层是一个数组），字符串常量池是JVM单独创建出来的一部分空间存储字符串常量的，如果字符串常量在内存有，那么就直接取出来用，如果没有，那么就会new String出来，并且保存一份到字符串常量池里面
字符型常量：单引号引用到char字符，占两个字节

### 三.方法

#### 1.什么是方法的返回值?方法有哪几种类型？

返回值：调用这个方法获取的结果
类型：无返回值有参数，无返回值无参数，有返回值有参数，有返回值无参数

#### 2.静态方法为什么不能调用非静态成员?

非晶态成员需要在对象初始化的是才会创建，但是静态方法在类加载的时候就会创建，所以静态方法拿不到没创建的成员信息

#### 3.静态方法和实例方法有何不同？

使用方法：静态方法可以直接使用ClassName.MethodName() 调用，而实例方法
创建时期：静态方法是类加载的是创建的，但是实例方法是在new的时候创建的的

#### 4.重载和重写有什么区别？

重载：是相同的方法名，不同的参数 例如一个String的方法有多个重载的方法
重写：重写一般是子类去重写父类的方法，重写的的返回类型应该小于等于父类的，异常类型也应该小于等于父类的异常

#### 5.什么是可变长参数？

method(args ....) 可以使用多个参数 然后底层是一个数组存储这些数据

### 四.面向对象基础

#### 1.面向对象和面向过程的区别

面向对象：使用的对象的方法来处理
面向过程：是把整个事情一部分分隔开，然后一个个执行 

#### 2.创建一个对象用什么运算符?对象实体与对象引用有何不同?

使用new 来创建一个对象 
对象引用指向内存地址

#### 3.对象的相等和引用相等的区别

对象相等是对象的值相等
引用相等是等内存地址是不是相等

#### 4.如果一个类没有声明构造方法，该程序能正确执行吗?

可以正确执行，因为创建的时候，默认创建了构造方法，可以隐性创建

#### 5.构造方法有哪些特点？是否可被 override?

构造方法不能被override，可以被重载
特点：可以有多个参数，没有返回值，无需调用

#### 6.面向对象三大特征

继承：只能继承一个父类，拥有父类的方法和属性（包括私有的），但是不能使用私有的
封装：类似空调，不需要了解里面有什么东西，只需要告诉遥控器，按什么就会输出什么就可以了
多态：一个方法的多个实现，最终是谁实现，运行的时候才知道   SonService service = new Service（）;
多态是指同一类型的对象，在不同的情况下表现出不同的行为。多态允许我们使用父类的引用指向子类的对象；多态通过方法的重写实现。

#### 7.接口和抽象类有什么共同点和区别？

继承：接口可以多继承；抽象类只能单即成
都不能被实例化、都可以包含抽象方法、都有default默认方法
常量：接口常量必须赋初始值，抽象类默认default

#### 8.深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

深拷贝：复制一个完整的内容，递归复制，有不同的内存地址，相互不影响
浅拷贝：只拷贝内存地址，修改另外拷贝的值，原有数据也会改变，用于基础类型或者不可变引用对象
引用拷贝：特殊的浅拷贝，只负责对象的引用；引用拷贝通常用于传递对象作为参数，以避免复制整个对象。

#### 9.Java值传递详解

java只能值传递，基础类型传递的是直接的值，引用类型传递的是内存地址

#### 10.Java魔法类Unsafe详解

是native修饰的方法，用来操作底层操作系统的内存、内存屏障等各种操作

### 五.Object

#### 1.Object 类的常见方法有哪些？

euqals()、clone（）、wait（）、getClass、hashCode  、toString、notify、notifyAll、

#### 2.== 和 equals() 的区别

基础类型，==是比较两个数据的内容，引用类型==是比较两个对象的内存地址是不是相等
equals是比较两个值是不是相等,但是大部分的对象里面建议重写equals()都被重写了,默认也是比较内存地址

#### 3.hashCode() 有什么用？

hashCode是每个对象都有的（通过对象的内容计算出来的），用于快速查找和区分对象
哈希表使用哈希码作为索引，从而实现高效的数据存储和检索。
如果两个对象的哈希码相同，哈希表会使用其他方法（例如 equals()）来区分它们。

#### 4.为什么要有 hashCode？

方便查找对象和数据，方便比较对象是否相等

#### 5.为什么重写 equals() 时必须重写 hashCode() 方法？

因为hashcode一样（hash碰撞💥），不一定两个对象相等，两个相等的第二个条件是equals也相等
如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。

### 六.String

#### 1.String、StringBuffer、StringBuilder 的区别？

线程安全：String线程安全 final 修饰，StringBuffer 线程安全 使用了synchronize修饰，StringBuilder线程不安全
性能：少量数据就String，大量数据 多线程就StringBuffer、单线程就是StringBuilder
String每次改变的时候都会创建一个新class
StringBuffer、StringBuilder：可变对象，每次都是操作原对象

#### 2.String 为什么是不可变的?

final修饰的

#### 3.字符串拼接用“+” 还是 StringBuilder?

+：每次都会创建一个新的对象，少量数据使用
StringBuilder使用append，大量数据使用

#### 4.String#equals() 和 Object#equals() 有何区别？

String的equals重写了的，比较值
Object的equals是比较对象的引用地址内存地址

#### 5.字符串常量池的作用了解吗？

jvm单独开辟的一块空间出来存放字符串常量池，如果没有，那么new一个对象到放到字符串常量池里面，存在就返回引用地址
节省内存空间

#### 6.String s1 = new String("abc");这句话创建了几个字符串对象？

如果abc在常量池不存在 那么创建两个对象，第一次创建对象放到内存中，第二次创建对象，把常量池中的引用过来
存在，那么就创建一次

#### 7.String#intern 方法有什么作用?

把字符串放到常量池里面，并返回引用

#### 8.String 类型的变量和常量做“+”运算时发生了什么？

常量是做了拼接，变量也是 内部使用了StringBuilder 然后toString 是一个新对象
引用的值在程序编译期是无法确定的，编译器无法对其进行优化。 
如果加了final修饰的string，那么在编译的时候就是常量相加了，不涉及到new新对象

### 七.异常

#### 1.Exception 和 Error 有什么区别？

Exception 是可以捕获到的
Error是无法捕获到的-比如OOM这种整个崩了

#### 2.Checked Exception 和 Unchecked Exception 有什么区别？

checked在代码编译过程中，如果有，那么就无法编译成功
unchecked的就算可能有问题，编译没啥问题，在执行到这段代码的时候就崩了

#### 3.Throwable 类常用方法有哪些？

getMessage、printStackinfo，toString、getLocalizedMessage

#### 4.try-catch-finally 如何使用？

不要在finally里面写返回值

#### 5.finally 中的代码一定会执行吗？

不一定，因为假设执行到一半，程序停了 啥都没有了

#### 6.如何使用 try-with-resources 代替try-catch-finally？

twr主要是为了做io流到关闭，程序会自动帮我关闭流，实现了AutoCloseable

#### 7.异常使用有哪些需要注意的地方？

exception打印了就不要抛出去了 要手动处理



### 八.泛型

#### 1.什么是泛型？有什么作用？

规范代码，增加通用性

#### 2.泛型的使用方式有哪几种？

泛型类 类似通用返回
泛型接口： 动态的对象 可以根据泛型动态返回
泛型方法：动态的对象 可以根据泛型动态返回

#### 3.项目中哪里用到了泛型？

Result类中使用了T 作为通用的返回对象

#### 4.通配符详解

T、E、等等



### 九.反射

#### 1.何谓反射？

反射 通过name或者class 拿到这个对象，然后获取到这个类的方法、属性 然后反向调用这个方法。
在框架中用的比较多

#### 2.反射的优缺点？

优：方便灵活
缺：跳过了很多的安全检查

#### 3.反射的应用场景？

AOP中的就用了动态代理（依赖反射）

### 十.注解

#### 1.何谓注解？

主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解本质是一个继承了Annotation 的特殊接口

#### 2.注解的解析方法有哪几种？

编译器直接扫描
运行的时候 通过反射操作

### 十一.SPI

#### 1.何谓 SPI?

service provide interface 
就是java定义一个接口，然后其他人自己实现自己的，然后再Application ClassLoader加载的时候 
会去扫面meta-info/service这个文件夹下 找到对应的class的全路径，然后扫描使用ServiceLoader加载进来

#### 2.SPI 和 API 有什么区别？

api是接口直接提供给别人获取结果
SPI 是提供接口给别人 让其实现自己要实现的功能

#### 3.SPI 的优缺点？

优：可以在Application classLoader加载的时候 把我们需要加载的class加载进去，跳过了双亲委派机制
缺：需要循环遍历查找 性能低，可以忽略

### 十二.序列化和反序列化

#### 1.什么是序列化?什么是反序列化?

文件数据传输的时候 需要序列化 转成字节流
接收数据的时候 需要反序列化 转成字符号

#### 2.如果有些字段不想进行序列化怎么办？

使用transient 修饰

#### 3.常见序列化协议有哪些？

jdk自带的、Kryo、json、xml

#### 4.为什么不推荐使用 JDK 自带的序列化？

不支持跨语言，性能差

### 十三.IO TODO

#### 1.Java IO 流了解吗？

字节（输入/输出流）流
字符（输入/输出流）流

#### 2.I/O 流为什么要分为字节流和字符流呢?

#### 3.Java IO 中的设计模式有哪些？

#### 4.BIO、NIO 和 AIO 的区别？



### 十四.语法糖

#### 1.什么是语法糖？

简化操作，方便阅读

#### 2.Java 中有哪些常见的语法糖？

增强for、泛型、拆箱装箱、trywith resource、lambda



### 十五.集合

#### 1.说说 List, Set, Queue, Map 四者的区别？集合框架底层数据结构总结？

- List 有顺序且不唯一 底层是数组
      LinkedList：使用了链表
      Vector：数组
      ArrayList：底层是数组

- Set 无序且唯一 底层是hashMap 基本上都用了hashMap的方法，put方法的时候 先去调用map的put方法判断下数据是否存在，如果有就插入数据失败，否则成功
      HashSet：底层用HashMap
      LinkedHashSet：底层用LinkedHashMap
      TreeSet：底层红黑树 （有序、唯一）
- Queue 先进先出 有序可重复
      PriorityQueue: 最小堆
      DelayQueue： 延迟队列
      Dqueue：双向队列
      BlockingQueue：阻塞队列

- Map 一对一 ，key,value都可以null
      HashMap：数组加链表 链表主要是为了解决hash冲突，当链表长度大于8，就会考虑转化为红黑树（转化的时候会判断数组的长度有没有大于64，小于64就会先扩容）
      LinkedHashMap：数组加双向链表和红黑树，实现了访问顺序
      HashTable：不再使用了，数组加链表，链表为了解决hash冲突
      TreeSet：红黑树，自平衡的二叉树

### 3.如何选用集合?

- Map：线程安全用ConcurrentHashMap，非线程安全使用hashmap
- Set：看是否有序，有序就TreeSet，其他的就hashSet
- List：线程安全用Vector，线程不安全使用ArrayList

### 5.List

#### 5.1.ArrayList 和 Array（数组）的区别？

Array：普通的数组（静态）
ArrayList： 底层是数组，但是多了很多方法，动态扩容，可以存储对象，基本类型需要装箱

#### 5.2.ArrayList 可以添加 null 值吗？

可以

#### 5.3.ArrayList 插入和删除元素的时间复杂度？

如何删除第一个元素 那么就是n，因为所有的元素都要往前移动，如果删除最后1个元素 那么就是1，指定位置n/2
插入尾部的话是1，指定位置的n/2 ,如果要扩容 也是n

#### 5.4.LinkedList 插入和删除元素的时间复杂度？

指定位置是n/2
其他的位置（首位） 都是n ，改动链表指向

#### 5.5.LinkedList 为什么不能实现 RandomAccess 接口？

LinkedList是双向链表，没有固定的内存空间，不支持随机访问

#### 5.6.ArrayList 与 LinkedList 区别?

线程安全：都是不安全的
底层结构：ArrayList是数组，LinkedList是链表
内存空间：A是连续的，l花费的空间比a多，链表信息要保存
支持快速范围：a可以，l不行

#### 5.7.说一说 ArrayList 的扩容机制吧

初始值是10，当判断容量不够的时候，就根据增长因子（默认1.5）会扩容1.5倍
会先创建一个大数组，然后copy数据过去

### 6.Set

#### 6.1.Comparable 和 Comparator 的区别

Comparable 接口用于自然排序，即对象本身具有默认的排序顺序。
Comparator 接口用于外部比较，允许我们在不修改原始类的情况下定义不同的比较规则。

#### 6.2.无序性和不可重复性的含义是什么

无序性：没有固定的顺序
不可重复性：每个值都是唯一的

#### 6.3.比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

线程安全：都是线程不安全的
顺序性：TreeSet是顺序的
底层结构：HashSet是hashmap、LinkedHashSet是LinkedHashMap、TreeSet是红黑树

### 7.Queue

#### 7.1.Queue 与 Deque 的区别

Q是单向队列，D是双向队列

#### 7.2.ArrayDeque 与 LinkedList 的区别

底层：A属于数组+指针 L属于链表

NULL：A不能存，但是L可以存空数据

性能上：A做队列比L性能好一些



#### 7.3.说一说 PriorityQueue

元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。
利用了二叉堆的数据结构来实现的，默认是小顶堆底层使用可变长的数组来存储数据
线程非安全

#### 7.4.什么是 BlockingQueue？

ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。
ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。
ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

#### 7.5.BlockingQueue 的实现类有哪些？

是一个接口，继承自 Queue。BlockingQueue阻塞的原因是：其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。

#### 7.6.ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？



### 8.Map

#### 8-1.HashMap 和 Hashtable 的区别

线程安全：map不安全。table是线程安全的
性能：map的更好更快，table的慢一些（淘汰）
null支持：map都支持key。value ；table不支持

#### 8-2.HashMap 和 HashSet 区别

HashSet底层就是hashMap
存储的数据不一样，一个是keyvalue，一个是value值 
重复值的问题，map值可以重复，set不得行

#### 8-3.HashMap 和 TreeMap 区别

treeMap key会排序，集合内元素的搜集

#### 8-4.HashSet 如何检查重复?

去调用hashmap的put方法 ，判断有没有值，然后判断插入成功还是失败

#### 8-5.HashMap 的底层实现

底层是数组➕链表+红黑树，如果出现了hash冲突，那么就会把数据放到链表里面，
当链表长度大于8，就会考虑转化为红黑树（转化的时候会判断数组的长度有没有大于64，小于64就会先扩容）

#### 8-6.HashMap 的长度为什么是 2 的幂次方

为了减少hash碰撞

#### 8-7.HashMap 多线程操作导致死循环问题

1.8之前，因为扩容会出现该问题
1.8之后优化的了操作，不会再出现，但是1.8之后出现了多线程 put的问题

#### 8-8.HashMap 为什么线程不安全？

可能出现多个线程同时操作，进行put

#### 8-9.HashMap 常见的遍历方式?

keyset，entry等

#### 8-10.ConcurrentHashMap 和 Hashtable 的区别

线程安全：都是线程安全的 ，table使用了synchronize，而concurrentHashMap使用了数组链表加红黑树了，

#### 8-11.ConcurrentHashMap 线程安全的具体实现方式/底层具体实现 TODO





#### 8-12.JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？

1.7 是使用segement（node+cas+synchronize）
1.8 使用 数组链表+红黑树

#### 8-13.ConcurrentHashMap 为什么 key 和 value 不能为 null？

为了避免二义性

#### 8-14.ConcurrentHashMap 能保证复合操作的原子性吗？

有原子操作的方法可以实现





## 九.Thread

#### 1.何为进程?

系统中，开的一个个软件，在控制台里面，就是一个个进程

#### 2.何为线程?

线程就是 new Thread ，进程下一个更小的单位 

#### 3.Java 线程和操作系统的线程有啥区别？

#### 4.图解进程和线程的关系

#### 5.程序计数器为什么是私有的?

程序计数器是记录每个线程执行到哪一步，然后进入下一个方法 出栈后，返回 继续执行，肯定只能私有，共享就乱了

#### 6.虚拟机栈和本地方法栈为什么是私有的?



#### 7.一句话简单了解堆和方法区

- 堆：所有new 的对象都放在 heap区，是线程共享的
-  Method Area：里面有字符串常量池，meat-space（类的基本信息等）  运行常量池（字节码定义的一些变量）

#### 8.并发与并行的区别

并行，两个或者多个 **同一 时间段** 一起工作
并发，两个或者多个 **在同一时刻** 一起工作

#### 9.同步和异步的区别

同步：顺序执行，必须等每一步都完成
异步：不需要等到结果返回 去干其他的

#### 10.为什么要使用多线程?

多线程提升效率，大多数情况，多件事情多个人一起做肯定更快

#### 11.使用多线程可能带来什么问题?

线程不安全的问题、内存溢出问题

#### 12.如何理解线程安全和不安全？

线程不安全，可能两个人同时操作一个数据，导致数据错乱，错误等



#### 13.单核 CPU 上运行多个线程效率一定会高吗？

不一定，多个人有沟通成本，多个人一起抢时间片，其实更耗费时间

#### 15.如何创建线程？

```
new Thread、实现runnable接口 、使用competeFuture 、使用线程池、使用FutureTask等，但是底层都是使用new Thread
```

#### 16.说说线程的生命周期和状态?

NEW --> RUNNABLE--> TERMINATED

NEW
RUNNABLE
TERMINATED
BLOCKED
WAITING
TIME_WAITING

#### 17.什么是线程上下文切换?

```
线程A执行的时候，被wait了或者其他操作失去锁了，这个时候，线程A就要cpu的执行权放出去，就要从RUNNABLE状态换成BLOCKED状态  
```

#### 18.认识线程死锁

```
举个例子，一个大圆桌上吃饭，每个人都在等上一个人给的筷子才能开始吃饭，可是每一个人的上个人都没有筷子 死循环
或者说 两个线程等待对方释放锁，都双双卡住
```

#### 19.如何预防和避免线程死锁?

```
一次性申请所有资源，破坏循环条件等
```

#### 20.sleep() 方法和 wait() 方法对比

```
关于锁的释放：sleep不释放锁，wait是释放锁的
关于方法来源：sleep是Thread的方法，notify是Object的方法
是否会自动苏醒：sleep到时间后，会苏醒，wait不会
最终状态（假设都是从RUNNABLE调用）：sleep会变成TIME_WAITING,wait会变成WAITING
```

#### 21.为什么 wait() 方法不定义在 Thread 中？

```
wait使用对象级别的，是让获得对象锁的的线程实现等待，会自动释放当前线程占用的对象锁
```

#### 22.可以直接调用 Thread 类的 run 方法吗？

```
不行，直接调用就变成一个普通的方法，必须先执行start，这个操作会执行一些准备工作
```



## 十.JMM(Java 内存模型

#### 1.volatile 关键字

```
防止重排序
保证变量的可见性，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
```

#### 2.如何保证变量的可见性？

```
使用volatile关键字修饰s
```

#### 3.如何禁止指令重排序？

```
使用volatile关键字修饰
```

#### 4.volatile 可以保证原子性么？

```
不可以
```

#### 5.什么是悲观锁？

```
就是觉得每次都会有人来抢占线程，所以每次都要加锁，其他的线程都等待
适用于：写比较多的场景
```

#### 6.什么是乐观锁？

```
觉得没有人来抢占锁，共享资源不会冲突 只是在最后提交修改的去验证下是否被修改
适用于：写比较少的场景
```

#### 7.如何实现乐观锁？

```
使用版本号判断
```

#### 8.CAS 算法

```

```

#### 9.乐观锁存在哪些问题？

```

```

#### 10.synchronized 是什么？有什么用？

```
使用
```

#### 11.如何使用 synchronized？

```

```

#### 12.构造方法可以用 synchronized 修饰么？

```
不能使用synchronized修饰构造方法

```

13.synchronized 底层原理了解吗？

14.synchronized 和 volatile 有什么区别？
15.ReentrantLock 是什么？
16.公平锁和非公平锁有什么区别？
17.synchronized 和 ReentrantLock 有什么区别？
18.可中断锁和不可中断锁有什么区别？

## 十一.ThreadLocal

#### 1.ThreadLocal 有什么用？

```

```

#### 2.如何使用 ThreadLocal？

```

```

#### 3.ThreadLocal 原理了解吗？

```

```

#### 4.ThreadLocal 内存泄露问题是怎么导致的？

```

```



## 十二.线程池

#### 1.什么是线程池?

```
线程池是一种多线程处理形式，它在初始化一个多线程应用程序过程中创建一个线程集合。
线程池的主要目的是为了复用线程、便利地管理线程和任务、并将线程的创建和任务的执行解耦开来。
```

#### 2.为什么要用线程池？

```
降低资源消耗：通过复用已创建的线程，可以降低创建和销毁线程的消耗。
提高响应速度：当任务到达时，可以不需要等待线程的创建就能立即执行。
提高线程的可管理性：使用线程池可以统一分配、调优和监控线程。
```

#### 3.如何创建线程池？

```
1.推荐使用new ThreadPoolExecutors() 来创建
2.Executors.newFixedThreadPool()来创建等
```

#### 4.为什么不推荐使用内置线程池？

```

```

#### 5.线程池常见参数有哪些？如何解释？

```
corePoolSize：核心线程数，从0开始到一定的范围，会一直存活

maximumPoolSize：最大线程池数，只要任务的数据大于核心线程，那么就会起新的线程

keepAliveTime：空闲最大存活时间，当空闲线程大于核心线程数据的时候，就会逐步被销毁，逐渐恢复到核心线程数

unit：时间单位

workQueue：队列，阻塞队列，默认是无边界，假设没有设置capacity，那么只要有无数的任务进来，内存就会溢出
   ArrayBlockingQueue：这是一个基于数组的有界阻塞队列，按FIFO（先进先出）原则对元素进行排序。
   LinkedBlockingQueue：这是一个基于链表的阻塞队列，按FIFO原则对元素进行排序。它的容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。
   SynchronousQueue：这是一个特殊的阻塞队列，它没有容量，每执行一个插入操作就会阻塞，需要有另一个线程进行取出操作。
   LinkedBlockingDeque：这是一个基于链表的双向阻塞队列，两端都可以进行元素的读写操作。
   DelayQueue：这是一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从队列中提取元素。

threadFactory：线程工厂有个newThread()的方法，用于创建线程
			可以使用内部类，然后自定义方法

handler：拒绝策略，有四种拒绝策略
	new ThreadPoolExecutor.AbortPolicy() // 默认策略，如果队列满了，那么就会直接抛异常
	new ThreadPoolExecutor.CallerRunsPolicy(); // 不会丢弃任务，把任务交给当前调用线程来执行，变成了同步
	new ThreadPoolExecutor.DiscardOldestPolicy(); // 会丢弃入队最久的任务，然后尝试将当前要拒绝的任务加入到队列来
	new ThreadPoolExecutor.DiscardPolicy();// 静默丢弃无法处理的任务，不会报错

```

#### 12.线程池处理任务的流程了解吗？



#### 13.如何给线程池命名？

```java
// 使用线程工厂
ThreadFactory threadFactory = new ThreadFactory() {
            private final AtomicInteger poolNumber = new AtomicInteger(1);

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "pool-" + poolNumber.getAndIncrement() + "-thread");
            }
        };
```

#### 14.如何设定线程池的大小？

```
CPU的核心数：可以使用Runtime.getRuntime().availableProcessors()方法来获取。

任务的类型：
CPU密集型任务需要大量的CPU资源：
				理论上线程的数量等于CPU核数就是最合适的，不过通常把线程的数量设置为CPU核数+1，会实现最优的利用率。这是因为当密集型的线					程由于偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程也能确保CPU的时钟周期不会被浪费，从而保证CPU的利用率。

IO密集型任务则会有大量的等待时间：
				最大线程数一般会大于CPU核心数很多倍。这是因为IO读写速度相比于CPU的速度而言是比较慢的，如果设置过少的线程数，就可能导致CPU资源的浪费。而如果设置更多的线程数，那么当一部分线程正在等待IO的时候，它们此时并不需要CPU来计算，那么另外的线程便可以利用CPU去执行其他的任务，互不影响。

线程数 = CPU核心数 * (1 + IO耗时/CPU耗时) 
或者线程数 = CPU核心数 / (1 - 阻塞系数)，其中计算密集型阻塞系数为0，IO密集型阻塞系数接近1，一般认为在0.8~0.9之间。
```

#### 15.如何动态修改线程池的参数？

- 使用配置中心来动态修改参数（主要修改三个参数，最大线程数，核心线程数据，和队列的的capacity 这个字段是final的，需要手动个改写去掉final）
- 使用修改框架hippo4j、dynamic-tp

#### 16.如何设计一个能够根据任务的优先级来执行的线程池？

```
那可以考虑使用 PriorityBlockingQueue （优先级阻塞队列）作为任务队列，但是是无界的，容易oom。并且需要重写compareTo方法。

```

#### 17.Future 类有什么用？

```
可以进行异步操作，专心做其他的事情，主要有下面四个方法：
取消任务；
判断任务是否被取消;
判断任务是否已经执行完成;
获取任务执行结果。
```

#### 18.Callable 和 Future 有什么关系？

```
我们可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。
FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。


```



#### 19.CompletableFuture 类有什么用？

```
Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。
Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。

```

**面试题：**

如果设定一个线程池，核心线程数为0，最大线程数为5，队列的capacity为10，那么这个时候有8个任务进来，请问如何处理？

> 核心线程数为0，那么先会进队列，然后起一个临时线程，来一个个执行对应的任务，**只会起一个临时线程**，执行完毕后，会根据存活时间死亡。

如果这个时候会有大于阻塞队列的长度的任务进来？

> 会出现多种情况，第一个任务执行的时间很长，那么会最大线程数的线程去执行任务，如果任务执行时间很少，那么可能不会创建很多临时线程去处理这个任务。
