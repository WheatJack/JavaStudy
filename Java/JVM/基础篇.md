 ![image-20240112211249969](./img/1.png)



# 1、基础篇

## 初始JVM

### 什么是JVM

JVM本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。

![image-20240113220844018](./img/2.png)



### JVM的功能

**1、解释和运行**

- 对字节码文件中的指令，实时的解释称机器码，让计算机执行

**2、内存管理**

- 自动为对象、方法等分配内存
- 自动的垃圾回收机制，回收不在使用的对象

**3、即时编译**

对热点代码进行优化，提升执行效率



### 即时编译

Java语言如果不做任何优化，性能不如C++等语言。

> **因为是实时解释为机器码**

![image-20240113221332594](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240113221332594.png)

而其他的C++语言是打包编译称可执行文件（机器码）

> **直接运行机器码**

![image-20240113221345653](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240113221345653.png)

**Java需要实时解释的原因？**

> 主要是问了跨平台特性

![image-20240113221444191](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240113221444191.png)

![image-20240112212203984](./img/7.png)

JVM提供了**即时编译**（Just-In-Time 简称JIT）进行性能优化，最终能够达到接近C++语言的运行性能，甚至在特定的场景下实现了超越。



### 常见的JVM

![image-20240112212234283](./img/9.png)



常见的JVM-HotSpot的发展历程

![image-20240112212829319](./img/10.png)



## 字节码文件详解

### 1.Java虚拟机的组成

主要包括：

- 类加载器
- 运行时数据区域（JVM管理的内存）
- 执行引擎（即时编译器、解释器、垃圾回收器等）

![image-20240112213321990](./img/13.png)



### 2.字节码文件的组成

主要包括：

- 基本信息
- 常量池
- 接口
- 方法
- 属性

![image-20240112214640168](./img/15.png)

**查看字节码常用的工具**

- Javap命令

- Jclasslib软件或者插件

  > ![image-20240112215217620](./img/11.png)
  >
  > github地址：https://github.com/ingokegel/jclasslib

- Arthus

  > 官网地址：https://arthas.aliyun.com/doc/





#### 1）基本信息

**Magic魔数**

- 文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容
- 软件使用文件的头几个字节（文件头）去检验文件的类型，如果软件不支持该种类型就会出错。
- Java字节码文件中，该文件头称为Magic魔数

![image-20240113223527525](./img/12.png)

常见的文件头

![image-20240113223754367](./img/24.png)



**主副版本号**

- 主副版本号指的是编译字节码文件的JDK版本号，主版本号是用来识别大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本号就加1，副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。
- 版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容

> Tips:
>
> 1.2之后大版本号计算的方式就是主版本号-44 
>
> 例如：主版本号52就是JDK8



![image-20240113230402739](./img/16.png)

![image-20240112220051858](./img/25.png)

![image-20240113230833483](./img/26.png)

| 名称               | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| Magic魔数          | 固定为0XCAFEBABE 不会改变                                    |
| 主副版本号         | 编译字节码的JDK版本                                          |
| 访问标识           | 标识是类还是接口、枚举、注解、模块 标识public、final、abstract |
| 类、父类、接口索引 | 通过这些索引可以找到类、父类、接口的信息                     |



#### 2）常量池

字节码文件中常量池的作用：

- 避免相同的内容重复定义、节省空间。

```
    public static String A = "中国";
    public static String B = "中国";
```

> 其他的相同的字段就会去引用到 真正的string字面量

![image-20240112222511280](./img/17.png)

> 如果是常量 那么会指向常量池里面的index 最终找到字面量
>
> 如果是普通的 是存在常量池里面 那么会直接找到对应的字面量值

- 常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。

- 字节码指令中通过编号引用到常量池的过程称之为符号引用

  > ![image-20240113232200998](./img/18.png)![image-20240113232211200](./img/19.png)





#### 3）方法

- 字节码中的方法区域是存放**字节码指令**的核心位置，字节码指令的内容放在方法的code属性中

  > ![image-20240113232345246](./img/20.png)

![image-20240112225630253](./img/21.png)

![image-20240112225750701](./img/22.png)



**通过字节码指令分析下面三种“加1”的操作性能的高低？**

> 字节码行数越少 效率越高

```java
int i=0,j=0,k=0;
i++;
j=j+1;
k += 1;
```

> i和k一样行数
>
> j的行数最多



**字节码工具**

- javap -v

  > javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容
  >
  > 直接输入javap 查看所有参数
  >
  > 输入javap -v 字节码文件名称 查看具体的字节码信息（如果是jar包 需要用jar -xvf命令解压）
  >
  > > linux > 符号追加到指定的位置文件内

- Arthas

  > 官网地址：https://arthas.aliyun.com/doc/
  >
  > ![image-20240113140957469](./img/23.png)
  >
  > - jad类的全限定名：反编译已经加载类的源码
  >
  > - dump类的全限定名：dump已加载类的字节码文件到特定目录
  >
  >   > 全限名：**包名加类名**



### 3.类的生命周期

应用场景：

- 运行时常量池
- 多态的原理
- 类加载器的作用
- 类的加密和解密



#### 0）生命周期概述

**分为下面五个阶段：**

- 1-加载

- 2-连接

  > 重点知识：
  >
  > - 校验
  > - 准备
  > - 解析

- 3-初始化

- 4-使用

  > 距离：new一个对象
  >
  > ```
  > Class class = new Class();
  > Class<Class> clazz = Class.class;
  > Class class1 = clazz.newInstance();
  > ```
  >
  > 

- 5-卸载

  > 类的卸载主要体现在垃圾回收♻️机制



#### 1）加载阶段

- Loading阶段第一步是**类加载器**根据类的全限定名通过不同的渠道以二进制流的方式获取到字节码信息。

  - 本地文件- 磁盘上的字节码文件
  - 动态代理生成-程序运行时使用动态代理生成
  - 通过网络传输的类-早期的Applet技术使用

- 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中

  > 方法区：虚拟的空间
  >
  > Java8以后叫元空间

- 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。

  > 生成一个InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。
  >
  > ![image-20240114140938691](./img/27.png)

- 同时，Java虚拟机还在堆中生成一份与方法区中数据类似的java.lang.Class 对象

  > 作用：是在Java代码中去获取类的信息以及存储静态字段的字段（JDK8及之后）
  >
  > ![image-20240114141447375](./img/28.png)
  >
  > ![image-20240113144305816](./img/30.png)
  >
  > ![image-20240113144323237](./img/31.png)

  

  

**为什么有两个区？**

> 对于开发者来说，**只需要访问堆中的Class对象**而不需要访问方法区中所有信息
>
> **这样虚拟机就能很好地控制开发者访问数据的范围**
>
> ![image-20240113144512326](./img/32.png)



**查看内存中的对象**

- 推荐使用JDK自带的hsdb工具查看Java虚拟机内存信息。工具位于JDK安装目录下lib文件夹中的sa-jdi.jar

- 启动命令

  > ```shell
  > java -cp sa-jdi.jar sun.jvm.hotspot.HSDB
  > ```
  >
  > 然后使用对应的java进程端口号连接
  >
  > <img src="./img/33.png" alt="image-20240113192844569" style="zoom: 50%;" />
  >
  > ![image-20240114150009116](./img/34.png)

  

  **Tips💡**

> jps 命令：查看所有的java对象进程
>
> ![image-20240113193437270](./img/51.png)





#### 2）连接阶段

连接阶段主要包含***三个过程***：

- ***验证-验证内容是否满足《Java虚拟机规范》***

  > Linking阶段不需要程序员参与
  >
  > 主要验证四部分：
  >
  > - 文件格式验证，比如文件是否以0xCAFEBABE开头，主副版本号是否满足当前Java虚拟机版本要求
  > - 元信息验证，例如类必须有父类（super不能为空）
  > - 验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去
  > - 符号引用验证，例如是否访问了其他类中private的方法等

- ***给静态变量赋初值***

  > 只要讨论JDK8及以后的版本
  >
  > - 虽然赋值为1 但是初始值赋值为0
  >
  > ![image-20240114150957325](./img/35.png)
  >
  > - **准备阶段只会给静态变量赋初始值，而每一种基本数据类型和引用数据类型都有其初始值**
  >
  > ![image-20240114151135717](./img/36.png)
  >
  > - **final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。（因为值不能修改，已经确定了）**
  >
  > ![image-20240114151248373](./img/37.png)

  

- ***将常量池中的符号引用替换成指向内存的直接引用***

  > - **直接引用不在使用编号，而是使用内存中地址进行访问具体的数据**
  >
  > ![image-20240114151357606](./img/38.png)

> ***符号引用***是字节码文件中使用**编号**去常量池中找对应的内容，***直接引用***是去找内存地址的引用
>
> ![image-20240114152031342](./img/39.png)
>
> 类的信息已经加载在内存中







#### 3）初始化阶段

- 初始化阶段会执行**静态代码块中的代码**，并**为静态变量赋值**。执行流程与代码执行流程一致。

- 初始化阶段会执行字节码文件中**cliinit**部分的字节码指令。

  > **clinit**方法中和java执行的顺序一致
  >
  > ![image-20240114152342473](./img/40.png)



**以下几种方式会导致类的初始化：**

1. 访问一个类的静态变量或者静态方法，注意变量时**final修饰的并且等号右边时常量不会触发初始化**（已经在连接阶段的准备阶段已经初始化了）
2. 调用Class.forName(String className)
3. new 一个该类的对象时
4. 执行Main方法的当前类

**Tips💡**

> VM参数：
>
> ```
> -XX:+TraceClassLoading 参数可以打印出加载并初始化的类
> ```

**案例：**

> ![image-20240113195843126](./img/41.png)

> 执行main方法的时候 会先初始化clinit 执行当前main方法所在的对象静态代码块（**有且只会执行一次静态代码块**）所以打印D 然后执行main方法自己的A 
>
> **一个类*加载初始化*只会执行一次**
>
> 然后new一个对象的时候（可以创建多个对象 会初始化多次构造方法） **执行顺序：静态代码块-> 代码块-> 构造方法** ，因为main初始化（已经加载了本身）的时候已经执行了静态代码块 ，然后会先初始化该对象的构造方法（如果有局部代码块 那么init的时候会把该代码块放到构造方法里面一起执行）。
>
> ```java
> class Test001{
>     public static void main(String[] args) {
>         System.out.println("A");
>         new Test001();
>         new Test001();
>     }
> 
>     public Test001() {
>         System.out.println("B");
>     }
>     {
>         System.out.println("C");
>     }
>     static {
>         System.out.println("D");
>     }
> }
> ```
>
> **执行结果为：DACBCB**



clinit指令在特定情况下不会出现指令操作

比如：以下几种情况是***不会**进行初始化指令操作的*。

1. 无静态代码块且无静态变量赋值语句的
2. 有静态变量的声明，但是没有赋值语句的
3. 静态变量的定义使用final关键字的，这类变量会在（**连接阶段的准备阶段**）直接进行初始化
4. **直接访问父类的静态变量，不会出发子类的初始化**
5. 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法

**案例1：**

> ![image-20240114155119136](./img/42.png)
>
> **答案：先执行父类 把值赋值为1 然后执行子类。把值赋值为2 然后打印数据为2**

**案例2:**

> **数组的创建不会导致数组中元素的类进行初始化**
>
> ```java
> class Test001 {
>     public static void main(String[] args) {
>         Test002[] test001s = new Test002[10];
>     }
> }
> 
> class Test002 {
>     static {
>         System.out.println("D");
>     }
> }
> ```
>
> **答案：不会打印静态代码块**

**案例3:**

> **final修饰的变量如果赋值的内容需要执行指令才能得到结果，会执行clinit方法进行初始化**
>
> 
>
> ```java
> class Test001 {
>     public static void main(String[] args) {
>         System.out.println(Test002.a);
>     }
> }
> 
> class Test002 {
>     public static final int a = Integer.valueOf(1);
> 
>     static {
>         System.out.println("静态代码块运行");
>     }
> }
> ```
>
> **答案：是1 然后是打印文字**



### 4.类加载器

什么是类加载器？

> 类加载器（classLoader）是Java虚拟机提供给应用程序区实现获取类和接口字节码数据的技术

![image-20240114210334102](./img/43.png)

![image-20240114164002896](./img/44.png)



**类加载器的应用场景：**

- 企业级应用
  1. SPI机制
  2. 类的热部署
  3. Tomcat类的隔离
- 大量的面试题
  1. 什么是类的双亲委派机制
  2. 打破类的双亲委派机制
  3. 自定义类加载器
- 解决线上问题
  1. 使用Arthas不停机解决线上故障







#### 1）类加载器的分类

类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的

![image-20240114210830514](./img/45.png)

- 类加载器的设计JDK8和8之后的版本差别较大，JDK8及之后的版本中默认的累积载器有如下几种

**虚拟机时实现的：**

>**Bootstrap（启动类加载器）**
>
>虚拟机底层实现的C++，加载Java类中最核心的类

**Java实现的：**

> **Extension（扩展类加载器）**
>
> 允许扩展Java中比较通用的类
>
> **Application（应用程序类加载器）**
>
> 加载应用使用的类





类加载器的详细信息可以通过classloader命令查

> ```shell
> [arthas@60081]$ classloader
> ```
>
> 可以看到层级关系为最上层的父类为**BootstrapClassLoader**，其次**sun.misc.LauncherExtClassLoader**，在其次为**sun.misc.LauncherAppClassLoader**
>
> ![image-20240114215035975](./img/46.png)





##### **Bootstrap ClassLoader**

- Bootstrap ClassLoader 是由HotSpot虚拟机提供、使用C++编写的类加载器

- 默认加载Java安装目录下/jre/lib下的类文件

  > ![image-20240114215637896](./img/47.png)



**如果想用BootStrap ClassLoader 加载用户自己的jar包，有哪些方式？**

- （不推荐）把自己的jar包放入lib目录下，可能会出现文件名不匹配的问题也不会正常的被加载

- **（推荐）**使用VM参数进行扩展

  > 使用命令：
  >
  > ```
  > -Xbootclasspath/a:jar包目录/jar包名
  > ```
  >
  > 可以自己手动写一个类 然后使用vm参数把这个类加载进去，这个类可以写了static方法 打印日志  然后调用的这个 去指定引用这个类 forname 然后看结果 但是这个类加载器还是null 是属于bootstrap加载器



**Java中默认的类加载器**

- **Extension ClassLoader**和**Application ClassLoader**都是JDK中提供的，使用Java编写的类加载器
- 它们的源码都位于sun.misc,Launcher中，是一个静态内部类。继承自URLCLlassLoader。局部通过目录或者指定jar包将字节码文件加载到内存中。

![image-20240114221554145](./img/48.png)





##### Extension ClassLoader

- Extension ClassLoader 是JDK中提供的、使用Java编写的类加载器

- 默认加载Java安装目录/jre/lib/ext下的类文件

  > ![image-20240114221237025](./img/49.png)

**如果想用Extension ClassLoader 加载用户自己的jar包，有哪些方式？**

- （不推荐）把自己的jar包放入/j re/lib/ext/目录下，尽量不要去改JDK安装目录中的内容

- **（推荐）**使用VM参数进行扩展

  > 使用命令：
  >
  > ```
  > -Djava.ext.dirs=jar包目录进行扩展，这种方式会覆盖原是目录，所以需要用 ; 追加原始目录
  > ```



##### Application ClassLoader

- 自己写的代码默认就是Application ClassLoader



**使用Arthas查看类加载器**

![image-20240114222734187](./img/50.png)



#### 2）双亲委派机制

> 由于Java虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁来加载的问题

**双亲委派机制有什么作用？**

1. 保证类加载的安全性

   > 通过双亲委派机制避免恶意代码替换JDK的核心类库，比如java.lang.String，确保核心类库的完整性和安全性

2. 避免重复加载

   > 可以避免一个类被反复多次加载



**什么是双亲委派机制？**

> 当一个类加载器接收到加载类当任务的时候，会**自底向上查找**是否加载过，再**由顶向下进行加载**
>
> 向下委派加载起到了一个加载优先级的作用
>
> ![image-20240114230839019](./img/52.png)

每个类都有一个父类加载器，**Application** 的父类是**Extension** ，**Extension**的parent是**Null**

- 在类加载的过程中，每个类加载器都会先检查是否已经加载类该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器，逐级向上

> ![image-20240114231300679](./img/53.png)

- 如果所有的父类加载器都没有加载该类，那么就会由最上层的类加载器开始**自顶向下**尝试加载类。

> ![image-20240114231505985](./img/54.png)



**问题：**

1. 如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？

   > 应该由Bootstrap ClassLoader来加载，该Loader优先级最高

2. String类能覆盖嘛？

   > String类不能重写，不会，且String类由Bootstrap ClassLoader来加载

3. 如何在Java中使用代码的方式去主动加载一个类？

   > - 使用Class.forName方法，使用当前的类的类加载器去加载指定的类
   >
   >   ```java
   >   
   >           Class<?> aClass = Class.forName("xxxx.xxxx");
   >           aClass.getClassLoader();
   >   ```
   >
   > - 获取类加载器，通过类加载器的loadClass() 指定某个类加载器加载
   >
   >   ```java
   >   ClassLoader classLoader = Test002.class.getClassLoader();
   >   Class<?> aClass1 = classLoader.loadClass("xxxx.xxx");
   >   ```



**每个Java实现的类加载器中保存了一个成员变量 parent类加载器，可以理解为上一级加载器，不是Java中继承关系和含义**

> ![image-20240114232844794](./img/55.png)





- Application加载器的parent是Extension 加载器，而**Extension加载的parent是Null**，但是在代码逻辑上，Extension ClassLoader依然会把Bootstrap ClassLoader当成父类加载器处理
- Bootstrap ClassLoader使用C++编写，没有parent加载器

![image-20240114233152391](./img/56.png)

使用Arthas查看ClassLoader的父子关系：

> ```shell
> classloader -t
> ```
>
> ![image-20240114233340193](./img/57.png)



##### **面试题**

**类的双亲委派机制是什么？**

1. 当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。
2. 应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器（**为Null**）。
3. 双亲委派机制的好处有两点: 第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。





#### 3）打破双亲委派机制

**打破双亲委派机制有哪些方式？**

- 自定义类加载器

  > 自定义类加载器并且重写loadclass方法，就可以将双亲委派机制的代码去除Tomcat通过这种方式实现应用之间类隔离，《面试篇》中分享它的做法

- 线程上下文加载器

  > 利用上下文类加载器加载类，比如JDBC和JNDI等

- Osgi框架的类加载器

  > 历史上osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载



**为什么有打破双亲委派机制？**

- 一个Tomcat程序是可以运行多个Web应用的，如果两个应用中出现了想吐的限定名的类，比如Servet类，Tomcat要保证这两个类能够加载并且它们应该是不同的类

- 如果不打破双亲委派机制，当应用类加载器加载Web应用1的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了

  > ![image-20240115112852947](./img/58.png)



##### 自定义类加载器

- Tomcat使用了自定义类加载器来实现应用之间类的隔离。每一个应用会有一个独立的类加载器加载相应的类。

![image-20240115113239937](./img/59.png)

- 先来分析ClassLoader的原理，ClassLoader中包含了4个核心方法

  > ```java
  > // 类加载的入口，提供了双亲委派机制。内部会调用findClass 重要
  > public Class<?> loadClass(String name) 
  > // 由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要
  > protected Class<?> findClass(String name)
  > // 做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中
  > protected final Class<?> defineClass(String name, byte[] b, int off, int len)
  > // 执行类生命周期中的连接阶段
  > protected final void resolveClass(Class<?> c)
  > ```
  >
  > 

- 双亲委派机制的核心代码就是位于loadClass方法中

- 打破双亲委派机制的核心就是将下面loadClass方法的代码重写

  > ```java
  > synchronized (getClassLoadingLock(name)) {
  >             // First, check if the class has already been loaded 首先检查该类是否已经加载
  >             Class<?> c = findLoadedClass(name);
  >             if (c == null) {
  >                 long t0 = System.nanoTime();
  >                 try {
  >                     if (parent != null) {
  >                       // 调用父类的方法去加载
  >                         c = parent.loadClass(name, false);
  >                     } else {
  >                         c = findBootstrapClassOrNull(name);
  >                     }
  >                 } catch (ClassNotFoundException e) {
  >                     // ClassNotFoundException thrown if class not found
  >                     // from the non-null parent class loader
  >                 }
  >               
  >               if (c == null) {
  >                     // If still not found, then invoke findClass in order
  >                     // to find the class. 如果父类加载不了 就自己来加载
  >                     long t1 = System.nanoTime();
  >                     c = findClass(name);
  > 
  >                     // this is the defining class loader; record the stats
  >                     sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
  >                     sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
  >                     sun.misc.PerfCounter.getFindClasses().increment();
  >                 }
  > ```

自定义类加载器的父类为什么是Application ClassLoader？

![image-20240115115419865](./img/60.png)

- JDK8为例，ClassLoader类中提供了构造方法设置parent内容：

  > ![image-20240115115850304](./img/61.png)
  >
  
- 这个构造方法由另一个构造方法调用，其中父类加载器由get SystemClassLoader方法设置。该方法返回的是Application ClassLoader

> ![image-20240115120137650](./img/62.png)



**两个自定义类加载器加载相同限定的类，不会冲突？？**

- 不会冲突，在同一个Java虚拟机中，只有**相同类加载器+相同的类限定名**才会被认为是同一个类

- 在Arthas中使用sc -d。classpath 可以查看具体情况

  > ​	![image-20240115122551265](./img/63.png)

- 正确的去实现一个自定义类加载器的方式是重写**findClass**方法，这样不会破坏双亲委派机制。

  > ![image-20240115122814322](./img/64.png)



##### 线程上下文加载器

- JDBC使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动

  > ![image-20240115132802106](./img/65.png)

- DriverManager位于rt.jar包中，由Bootstrap ClassLoader加载的

  > ![image-20240115133058064](./img/66.png)

- DriverManager位于rt.jar包中，由**Bootstrap ClassLoader**加载。而用户jar包中的驱动需要用**Application ClassLoader**来加载，这个就违反了双亲委派机制。

  > ![image-20240115133243345](./img/67.png)



###### **SPI机制**

- SPI全称为（Service Provider Interface），是JDK内置的一种服务提供发现服务

- ⭐️‼️SPI的**工作原理**：

  > 1. **驱动jar包-------在ClassPath路径下的META-INFO/services文件夹中，以接口的全限名来命名文件夹，对应的文件里面写该接口的实现**
  >
  >    ![image-20240115134137351](./img/68.png)
  >
  > 2. **使用ServiceLoader加载实现类---- DriverManager加载的是有个静态初始化的方法 加载驱动**
  >
  >    ![image-20240115134352644](./img/69.png)

- **DriverManager使用SPI机制，最终加载jar包中对应的驱动类**

  > ![image-20240115135346665](./img/70.png)



**JDBC案例总结**

- Bootstrap ClassLoader Load DriveManager
- 在初始化DriveManager的时候，通过SPI机制加载jar包中的mysql驱动
- SPI利用了线程上下文类加载器（ThreadContextClassLoader） 去加载并创建对象
- 这种由BootStrap ClassLoader加载的类，委派Application ClassLoader去加载类的方式，打破了双亲委派机制

![image-20240115140152864](./img/71.png)

> Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。
>
> 这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由**启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)**来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。
>
> 而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。



**JDBC案例中真的打破了双亲委派机制吗？？**

- **打破了**

  > 这种由启动类加载器加载的类，委派应用程序加载器去加载类的方式，打破了双亲委派机制

- **没有打破双亲委派机制**

  > ***JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制***





##### Osgi框架的类加载器



![image-20240114201023084](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201023084.png)





![image-20240114201150735](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201150735.png)

![image-20240114201441798](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201441798.png)



![image-20240114201525812](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201525812.png)





![image-20240114201613789](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201613789.png)





#### 4）JDK9以后的类加载器



![image-20240114201711256](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201711256.png)





![image-20240114201802987](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114201802987.png)







![image-20240114202018548](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114202018548.png)





#### 运行时数据区

![image-20240114203801964](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114203801964.png)



![image-20240114203923992](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114203923992.png)



![image-20240114203944940](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114203944940.png)



![image-20240114204033675](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204033675.png)



![image-20240114204111445](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204111445.png)

![image-20240114204212388](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204212388.png)

![image-20240114204355273](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204355273.png)

![image-20240114204430887](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204430887.png)



![image-20240114204515458](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204515458.png)



![image-20240114204652931](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204652931.png)



![image-20240114204733753](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114204733753.png)



![image-20240114205010282](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205010282.png)



![image-20240114205048839](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205048839.png)

![image-20240114205058859](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205058859.png)



![image-20240114205243935](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205243935.png)

![image-20240114205424304](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205424304.png)

![image-20240114205511822](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205511822.png)

![image-20240114205706314](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240114205706314.png)

> long类型 占用两个槽



##  JVM的内存区域











## JVM的垃圾回收





# 2、实战篇



# 3、高级篇





# 4、原理篇





# 5、面试题
