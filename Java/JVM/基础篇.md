 ![image-20240112211249969](./img/1.png)



# JVM基础篇

## 1.初始JVM

### 什么是JVM

JVM本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。

![image-20240113220844018](./img/2.png)



### JVM的功能

**1、解释和运行**

- 对字节码文件中的指令，实时的解释称机器码，让计算机执行

**2、内存管理**

- 自动为对象、方法等分配内存
- 自动的垃圾回收机制，回收不在使用的对象

**3、即时编译**

对热点代码进行优化，提升执行效率



### 即时编译

Java语言如果不做任何优化，性能不如C++等语言。

> **因为是实时解释为机器码**

![image-20240113221332594](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240113221332594.png)

而其他的C++语言是打包编译称可执行文件（机器码）

> **直接运行机器码**

![image-20240113221345653](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240113221345653.png)

**Java需要实时解释的原因？**

> 主要是问了跨平台特性

![image-20240113221444191](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240113221444191.png)

![image-20240112212203984](./img/7.png)

JVM提供了**即时编译**（Just-In-Time 简称JIT）进行性能优化，最终能够达到接近C++语言的运行性能，甚至在特定的场景下实现了超越。



### 常见的JVM

![image-20240112212234283](./img/9.png)



常见的JVM-HotSpot的发展历程

![image-20240112212829319](./img/10.png)



## 2.字节码文件详解

### 1.Java虚拟机的组成

主要包括：

- 类加载器
- 运行时数据区域（JVM管理的内存）
- 执行引擎（即时编译器、解释器、垃圾回收器等）

![image-20240112213321990](./img/13.png)



### 2.字节码文件的组成

主要包括：

- 基本信息
- 常量池
- 接口
- 方法
- 属性

![image-20240112214640168](./img/15.png)

**查看字节码常用的工具**

- Javap命令

- Jclasslib软件或者插件

  > ![image-20240112215217620](./img/11.png)
  >
  > github地址：https://github.com/ingokegel/jclasslib

- Arthus

  > 官网地址：https://arthas.aliyun.com/doc/





#### 1）基本信息

**Magic魔数**

- 文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容
- 软件使用文件的头几个字节（文件头）去检验文件的类型，如果软件不支持该种类型就会出错。
- Java字节码文件中，该文件头称为Magic魔数

![image-20240113223527525](./img/12.png)

常见的文件头

![image-20240113223754367](./img/24.png)



**主副版本号**

- 主副版本号指的是编译字节码文件的JDK版本号，主版本号是用来识别大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本号就加1，副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。
- 版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容

> Tips:
>
> 1.2之后大版本号计算的方式就是主版本号-44 
>
> 例如：主版本号52就是JDK8



![image-20240113230402739](./img/16.png)

![image-20240112220051858](./img/25.png)

![image-20240113230833483](./img/26.png)

| 名称               | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| Magic魔数          | 固定为0XCAFEBABE 不会改变                                    |
| 主副版本号         | 编译字节码的JDK版本                                          |
| 访问标识           | 标识是类还是接口、枚举、注解、模块 标识public、final、abstract |
| 类、父类、接口索引 | 通过这些索引可以找到类、父类、接口的信息                     |



#### 2）常量池

字节码文件中常量池的作用：

- 避免相同的内容重复定义、节省空间。

```
    public static String A = "中国";
    public static String B = "中国";
```

> 其他的相同的字段就会去引用到 真正的string字面量

![image-20240112222511280](./img/17.png)

> 如果是常量 那么会指向常量池里面的index 最终找到字面量
>
> 如果是普通的 是存在常量池里面 那么会直接找到对应的字面量值

- 常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。

- 字节码指令中通过编号引用到常量池的过程称之为符号引用

  > ![image-20240113232200998](./img/18.png)![image-20240113232211200](./img/19.png)





#### 3）方法

- 字节码中的方法区域是存放**字节码指令**的核心位置，字节码指令的内容放在方法的code属性中

  > ![image-20240113232345246](./img/20.png)

![image-20240112225630253](./img/21.png)

![image-20240112225750701](./img/22.png)



**通过字节码指令分析下面三种“加1”的操作性能的高低？**

> 字节码行数越少 效率越高

```java
int i=0,j=0,k=0;
i++;
j=j+1;
k += 1;
```

> i和k一样行数
>
> j的行数最多



**字节码工具**

- javap -v

  > javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容
  >
  > 直接输入javap 查看所有参数
  >
  > 输入javap -v 字节码文件名称 查看具体的字节码信息（如果是jar包 需要用jar -xvf命令解压）
  >
  > > linux > 符号追加到指定的位置文件内

- Arthas

  > 官网地址：https://arthas.aliyun.com/doc/
  >
  > ![image-20240113140957469](./img/23.png)
  >
  > - jad类的全限定名：反编译已经加载类的源码
  >
  > - dump类的全限定名：dump已加载类的字节码文件到特定目录
  >
  >   > 全限名：**包名加类名**



### 3.类的生命周期

应用场景：

- 运行时常量池
- 多态的原理
- 类加载器的作用
- 类的加密和解密



#### 0）生命周期概述

**分为下面五个阶段：**

- 1-加载

- 2-连接

  > 重点知识：
  >
  > - 校验
  > - 准备
  > - 解析

- 3-初始化

- 4-使用

  > 距离：new一个对象
  >
  > ```
  > Class class = new Class();
  > Class<Class> clazz = Class.class;
  > Class class1 = clazz.newInstance();
  > ```
  >
  > 

- 5-卸载

  > 类的卸载主要体现在垃圾回收♻️机制



#### 1）加载阶段

- Loading阶段第一步是**类加载器**根据类的全限定名通过不同的渠道以二进制流的方式获取到字节码信息。

  - 本地文件- 磁盘上的字节码文件
  - 动态代理生成-程序运行时使用动态代理生成
  - 通过网络传输的类-早期的Applet技术使用

- 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中

  > 方法区：虚拟的空间
  >
  > Java8以后叫元空间

- 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。

  > 生成一个InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。
  >
  > ![image-20240114140938691](./img/27.png)

- 同时，Java虚拟机还在堆中生成一份与方法区中数据类似的java.lang.Class 对象

  > 作用：是在Java代码中去获取类的信息以及存储静态字段的字段（JDK8及之后）
  >
  > ![image-20240114141447375](./img/28.png)
  >
  > ![image-20240113144305816](./img/30.png)
  >
  > ![image-20240113144323237](./img/31.png)

  

  

**为什么有两个区？**

> 对于开发者来说，**只需要访问堆中的Class对象**而不需要访问方法区中所有信息
>
> **这样虚拟机就能很好地控制开发者访问数据的范围**
>
> ![image-20240113144512326](./img/32.png)



**查看内存中的对象**

- 推荐使用JDK自带的hsdb工具查看Java虚拟机内存信息。工具位于JDK安装目录下lib文件夹中的sa-jdi.jar

- 启动命令

  > ```shell
  > java -cp sa-jdi.jar sun.jvm.hotspot.HSDB
  > ```
  >
  > 然后使用对应的java进程端口号连接
  >
  > <img src="./img/33.png" alt="image-20240113192844569" style="zoom: 50%;" />
  >
  > ![image-20240114150009116](./img/34.png)

  

  **Tips💡**

> jps 命令：查看所有的java对象进程
>
> ![image-20240113193437270](./img/51.png)





#### 2）连接阶段

连接阶段主要包含***三个过程***：

- ***验证-验证内容是否满足《Java虚拟机规范》***

  > Linking阶段不需要程序员参与
  >
  > 主要验证四部分：
  >
  > - 文件格式验证，比如文件是否以0xCAFEBABE开头，主副版本号是否满足当前Java虚拟机版本要求
  > - 元信息验证，例如类必须有父类（super不能为空）
  > - 验证程序执行指令的语义，比如方法内的指令执行到一半强行跳转到其他方法中去
  > - 符号引用验证，例如是否访问了其他类中private的方法等

- ***给静态变量赋初值***

  > 只要讨论JDK8及以后的版本
  >
  > - 虽然赋值为1 但是初始值赋值为0
  >
  > ![image-20240114150957325](./img/35.png)
  >
  > - **准备阶段只会给静态变量赋初始值，而每一种基本数据类型和引用数据类型都有其初始值**
  >
  > ![image-20240114151135717](./img/36.png)
  >
  > - **final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。（因为值不能修改，已经确定了）**
  >
  > ![image-20240114151248373](./img/37.png)

  

- ***将常量池中的符号引用替换成指向内存的直接引用***

  > - **直接引用不在使用编号，而是使用内存中地址进行访问具体的数据**
  >
  > ![image-20240114151357606](./img/38.png)

> ***符号引用***是字节码文件中使用**编号**去常量池中找对应的内容，***直接引用***是去找内存地址的引用
>
> ![image-20240114152031342](./img/39.png)
>
> 类的信息已经加载在内存中







#### 3）初始化阶段

- 初始化阶段会执行**静态代码块中的代码**，并**为静态变量赋值**。执行流程与代码执行流程一致。

- 初始化阶段会执行字节码文件中**cliinit**部分的字节码指令。

  > **clinit**方法中和java执行的顺序一致
  >
  > ![image-20240114152342473](./img/40.png)



**以下几种方式会导致类的初始化：**

1. 访问一个类的静态变量或者静态方法，注意变量时**final修饰的并且等号右边时常量不会触发初始化**（已经在连接阶段的准备阶段已经初始化了）
2. 调用Class.forName(String className)
3. new 一个该类的对象时
4. 执行Main方法的当前类

**Tips💡**

> VM参数：
>
> ```
> -XX:+TraceClassLoading 参数可以打印出加载并初始化的类
> ```

**案例：**

> ![image-20240113195843126](./img/41.png)

> 执行main方法的时候 会先初始化clinit 执行当前main方法所在的对象静态代码块（**有且只会执行一次静态代码块**）所以打印D 然后执行main方法自己的A 
>
> **一个类*加载初始化*只会执行一次**
>
> 然后new一个对象的时候（可以创建多个对象 会初始化多次构造方法） **执行顺序：静态代码块-> 代码块-> 构造方法** ，因为main初始化（已经加载了本身）的时候已经执行了静态代码块 ，然后会先初始化该对象的构造方法（如果有局部代码块 那么init的时候会把该代码块放到构造方法里面一起执行）。
>
> ```java
> class Test001{
>     public static void main(String[] args) {
>         System.out.println("A");
>         new Test001();
>         new Test001();
>     }
> 
>     public Test001() {
>         System.out.println("B");
>     }
>     {
>         System.out.println("C");
>     }
>     static {
>         System.out.println("D");
>     }
> }
> ```
>
> **执行结果为：DACBCB**



clinit指令在特定情况下不会出现指令操作

比如：以下几种情况是***不会**进行初始化指令操作的*。

1. 无静态代码块且无静态变量赋值语句的
2. 有静态变量的声明，但是没有赋值语句的
3. 静态变量的定义使用final关键字的，这类变量会在（**连接阶段的准备阶段**）直接进行初始化
4. **直接访问父类的静态变量，不会出发子类的初始化**
5. 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法

**案例1：**

> ![image-20240114155119136](./img/42.png)
>
> **答案：先执行父类 把值赋值为1 然后执行子类。把值赋值为2 然后打印数据为2**

**案例2:**

> **数组的创建不会导致数组中元素的类进行初始化**
>
> ```java
> class Test001 {
>     public static void main(String[] args) {
>         Test002[] test001s = new Test002[10];
>     }
> }
> 
> class Test002 {
>     static {
>         System.out.println("D");
>     }
> }
> ```
>
> **答案：不会打印静态代码块**

**案例3:**

> **final修饰的变量如果赋值的内容需要执行指令才能得到结果，会执行clinit方法进行初始化**
>
> 
>
> ```java
> class Test001 {
>     public static void main(String[] args) {
>         System.out.println(Test002.a);
>     }
> }
> 
> class Test002 {
>     public static final int a = Integer.valueOf(1);
> 
>     static {
>         System.out.println("静态代码块运行");
>     }
> }
> ```
>
> **答案：是1 然后是打印文字**



### 4.类加载器

什么是类加载器？

> 类加载器（classLoader）是Java虚拟机提供给应用程序区实现获取类和接口字节码数据的技术

![image-20240114210334102](./img/43.png)

![image-20240114164002896](./img/44.png)



**类加载器的应用场景：**

- 企业级应用
  1. SPI机制
  2. 类的热部署
  3. Tomcat类的隔离
- 大量的面试题
  1. 什么是类的双亲委派机制
  2. 打破类的双亲委派机制
  3. 自定义类加载器
- 解决线上问题
  1. 使用Arthas不停机解决线上故障







#### 1）类加载器的分类

类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的

![image-20240114210830514](./img/45.png)

- 类加载器的设计JDK8和8之后的版本差别较大，JDK8及之后的版本中默认的累积载器有如下几种

**虚拟机时实现的：**

>**Bootstrap（启动类加载器）**
>
>虚拟机底层实现的C++，加载Java类中最核心的类

**Java实现的：**

> **Extension（扩展类加载器）**
>
> 允许扩展Java中比较通用的类
>
> **Application（应用程序类加载器）**
>
> 加载应用使用的类





类加载器的详细信息可以通过classloader命令查

> ```shell
> [arthas@60081]$ classloader
> ```
>
> 可以看到层级关系为最上层的父类为**BootstrapClassLoader**，其次**sun.misc.LauncherExtClassLoader**，在其次为**sun.misc.LauncherAppClassLoader**
>
> ![image-20240114215035975](./img/46.png)





##### **Bootstrap ClassLoader**

- Bootstrap ClassLoader 是由HotSpot虚拟机提供、使用C++编写的类加载器

- 默认加载Java安装目录下/jre/lib下的类文件

  > ![image-20240114215637896](./img/47.png)



**如果想用BootStrap ClassLoader 加载用户自己的jar包，有哪些方式？**

- （不推荐）把自己的jar包放入lib目录下，可能会出现文件名不匹配的问题也不会正常的被加载

- **（推荐）**使用VM参数进行扩展

  > 使用命令：
  >
  > ```
  > -Xbootclasspath/a:jar包目录/jar包名
  > ```
  >
  > 可以自己手动写一个类 然后使用vm参数把这个类加载进去，这个类可以写了static方法 打印日志  然后调用的这个 去指定引用这个类 forname 然后看结果 但是这个类加载器还是null 是属于bootstrap加载器



**Java中默认的类加载器**

- **Extension ClassLoader**和**Application ClassLoader**都是JDK中提供的，使用Java编写的类加载器
- 它们的源码都位于sun.misc,Launcher中，是一个静态内部类。继承自URLCLlassLoader。局部通过目录或者指定jar包将字节码文件加载到内存中。

![image-20240114221554145](./img/48.png)





##### Extension ClassLoader

- Extension ClassLoader 是JDK中提供的、使用Java编写的类加载器

- 默认加载Java安装目录/jre/lib/ext下的类文件

  > ![image-20240114221237025](./img/49.png)

**如果想用Extension ClassLoader 加载用户自己的jar包，有哪些方式？**

- （不推荐）把自己的jar包放入/j re/lib/ext/目录下，尽量不要去改JDK安装目录中的内容

- **（推荐）**使用VM参数进行扩展

  > 使用命令：
  >
  > ```
  > -Djava.ext.dirs=jar包目录进行扩展，这种方式会覆盖原是目录，所以需要用 ; 追加原始目录
  > ```



##### Application ClassLoader

- 自己写的代码默认就是Application ClassLoader



**使用Arthas查看类加载器**

![image-20240114222734187](./img/50.png)



#### 2）双亲委派机制

> 由于Java虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁来加载的问题

**双亲委派机制有什么作用？**

1. 保证类加载的安全性

   > 通过双亲委派机制避免恶意代码替换JDK的核心类库，比如java.lang.String，确保核心类库的完整性和安全性

2. 避免重复加载

   > 可以避免一个类被反复多次加载



**什么是双亲委派机制？**

> 当一个类加载器接收到加载类当任务的时候，会**自底向上查找**是否加载过，再**由顶向下进行加载**
>
> 向下委派加载起到了一个加载优先级的作用
>
> ![image-20240114230839019](./img/52.png)

每个类都有一个父类加载器，**Application** 的父类是**Extension** ，**Extension**的parent是**Null**

- 在类加载的过程中，每个类加载器都会先检查是否已经加载类该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器，逐级向上

> ![image-20240114231300679](./img/53.png)

- 如果所有的父类加载器都没有加载该类，那么就会由最上层的类加载器开始**自顶向下**尝试加载类。

> ![image-20240114231505985](./img/54.png)



**问题：**

1. 如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？

   > 应该由Bootstrap ClassLoader来加载，该Loader优先级最高

2. String类能覆盖嘛？

   > String类不能重写，不会，且String类由Bootstrap ClassLoader来加载

3. 如何在Java中使用代码的方式去主动加载一个类？

   > - 使用Class.forName方法，使用当前的类的类加载器去加载指定的类
   >
   >   ```java
   >   
   >           Class<?> aClass = Class.forName("xxxx.xxxx");
   >           aClass.getClassLoader();
   >   ```
   >
   > - 获取类加载器，通过类加载器的loadClass() 指定某个类加载器加载
   >
   >   ```java
   >   ClassLoader classLoader = Test002.class.getClassLoader();
   >   Class<?> aClass1 = classLoader.loadClass("xxxx.xxx");
   >   ```



**每个Java实现的类加载器中保存了一个成员变量 parent类加载器，可以理解为上一级加载器，不是Java中继承关系和含义**

> ![image-20240114232844794](./img/55.png)





- Application加载器的parent是Extension 加载器，而**Extension加载的parent是Null**，但是在代码逻辑上，Extension ClassLoader依然会把Bootstrap ClassLoader当成父类加载器处理
- Bootstrap ClassLoader使用C++编写，没有parent加载器

![image-20240114233152391](./img/56.png)

使用Arthas查看ClassLoader的父子关系：

> ```shell
> classloader -t
> ```
>
> ![image-20240114233340193](./img/57.png)



##### **面试题**

**类的双亲委派机制是什么？**

1. 当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。
2. 应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器（**为Null**）。
3. 双亲委派机制的好处有两点: 第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。





#### 3）打破双亲委派机制

**打破双亲委派机制有哪些方式？**

- 自定义类加载器

  > 自定义类加载器并且重写loadclass方法，就可以将双亲委派机制的代码去除Tomcat通过这种方式实现应用之间类隔离，《面试篇》中分享它的做法

- 线程上下文加载器

  > 利用上下文类加载器加载类，比如JDBC和JNDI等

- Osgi框架的类加载器

  > 历史上osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载



**为什么有打破双亲委派机制？**

- 一个Tomcat程序是可以运行多个Web应用的，如果两个应用中出现了想吐的限定名的类，比如Servet类，Tomcat要保证这两个类能够加载并且它们应该是不同的类

- 如果不打破双亲委派机制，当应用类加载器加载Web应用1的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了

  > ![image-20240115112852947](./img/58.png)



##### 自定义类加载器

- Tomcat使用了自定义类加载器来实现应用之间类的隔离。每一个应用会有一个独立的类加载器加载相应的类。

![image-20240115113239937](./img/59.png)

- 先来分析ClassLoader的原理，ClassLoader中包含了4个核心方法

  > ```java
  > // 类加载的入口，提供了双亲委派机制。内部会调用findClass 重要
  > public Class<?> loadClass(String name) 
  > // 由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要
  > protected Class<?> findClass(String name)
  > // 做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中
  > protected final Class<?> defineClass(String name, byte[] b, int off, int len)
  > // 执行类生命周期中的连接阶段
  > protected final void resolveClass(Class<?> c)
  > ```
  >
  > 

- 双亲委派机制的核心代码就是位于loadClass方法中

- 打破双亲委派机制的核心就是将下面loadClass方法的代码重写

  > ```java
  > synchronized (getClassLoadingLock(name)) {
  >             // First, check if the class has already been loaded 首先检查该类是否已经加载
  >             Class<?> c = findLoadedClass(name);
  >             if (c == null) {
  >                 long t0 = System.nanoTime();
  >                 try {
  >                     if (parent != null) {
  >                       // 调用父类的方法去加载
  >                         c = parent.loadClass(name, false);
  >                     } else {
  >                         c = findBootstrapClassOrNull(name);
  >                     }
  >                 } catch (ClassNotFoundException e) {
  >                     // ClassNotFoundException thrown if class not found
  >                     // from the non-null parent class loader
  >                 }
  >               
  >               if (c == null) {
  >                     // If still not found, then invoke findClass in order
  >                     // to find the class. 如果父类加载不了 就自己来加载
  >                     long t1 = System.nanoTime();
  >                     c = findClass(name);
  > 
  >                     // this is the defining class loader; record the stats
  >                     sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
  >                     sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
  >                     sun.misc.PerfCounter.getFindClasses().increment();
  >                 }
  > ```

自定义类加载器的父类为什么是Application ClassLoader？

![image-20240115115419865](./img/60.png)

- JDK8为例，ClassLoader类中提供了构造方法设置parent内容：

  > ![image-20240115115850304](./img/61.png)
  >
  
- 这个构造方法由另一个构造方法调用，其中父类加载器由get SystemClassLoader方法设置。该方法返回的是Application ClassLoader

> ![image-20240115120137650](./img/62.png)



**两个自定义类加载器加载相同限定的类，不会冲突？？**

- 不会冲突，在同一个Java虚拟机中，只有**相同类加载器+相同的类限定名**才会被认为是同一个类

- 在Arthas中使用sc -d。classpath 可以查看具体情况

  > ​	![image-20240115122551265](./img/63.png)

- 正确的去实现一个自定义类加载器的方式是重写**findClass**方法，这样不会破坏双亲委派机制。

  > ![image-20240115122814322](./img/64.png)



##### 线程上下文加载器

- JDBC使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动

  > ![image-20240115132802106](./img/65.png)

- DriverManager位于rt.jar包中，由Bootstrap ClassLoader加载的

  > ![image-20240115133058064](./img/66.png)

- DriverManager位于rt.jar包中，由**Bootstrap ClassLoader**加载。而用户jar包中的驱动需要用**Application ClassLoader**来加载，这个就违反了双亲委派机制。

  > ![image-20240115133243345](./img/67.png)



###### **SPI机制**

- SPI全称为（Service Provider Interface），是JDK内置的一种服务提供发现服务

- ⭐️‼️SPI的**工作原理**：

  > 1. **驱动jar包-------在ClassPath路径下的META-INFO/services文件夹中，以接口的全限名来命名文件夹，对应的文件里面写该接口的实现**
  >
  >    ![image-20240115134137351](./img/68.png)
  >
  > 2. **使用ServiceLoader加载实现类---- DriverManager加载的是有个静态初始化的方法 加载驱动**
  >
  >    ![image-20240115134352644](./img/69.png)

- **DriverManager使用SPI机制，最终加载jar包中对应的驱动类**

  > ![image-20240115135346665](./img/70.png)



**JDBC案例总结**

- Bootstrap ClassLoader Load DriveManager
- 在初始化DriveManager的时候，通过SPI机制加载jar包中的mysql驱动
- SPI利用了线程上下文类加载器（ThreadContextClassLoader） 去加载并创建对象
- 这种由BootStrap ClassLoader加载的类，委派Application ClassLoader去加载类的方式，打破了双亲委派机制

![image-20240115140152864](./img/71.png)

> Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。
>
> 这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由**启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)**来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。
>
> 而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。



**JDBC案例中真的打破了双亲委派机制吗？？**

- **打破了**

  > 这种由启动类加载器加载的类，委派应用程序加载器去加载类的方式，打破了双亲委派机制

- **没有打破双亲委派机制**

  > ***JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制***



##### Osgi框架的类加载器

- 历史上，OSGI模块化框架。它存在同级之间的类加载器的委托加载。OSGI还使用类加载器实现了**热部署**的功能

  > ![image-20240115142121335](./img/72.png)

- 热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。





**使用Arthas不停机解决线上问题**

> 只适合改极少数代码，已经不能停机的这种情况

**思路:**

- 在出问题的服务器上部署一个 arthas，并启动。
- jad --source-only 类全限定名 >目录/文件名javajad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码
- mc -c 类加载器的hashcode 目录/文件名.java -d 输出目录mc 命令用来编译修改过的代码
- retransform class文件所在目录/xxx.class用 retransform 命令加载新的字节码

**注意事项：**

- 程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。
- 使用retransform不能添加方法或者字段，也不能更新正在执行中的方法





#### 4）JDK9以后的类加载器

- JDK8之前的版本中，Extension ClassLoader 和Application ClassLoader的源码都是位于rt.jar包中的sun.misc.Launcher.java

  > ![image-20240115143630152](./img/73.png)

- JDK9引入类module打概念，类加载器在设计上发生了许多变化

  > 1. Bootstrap ClassLoader使用Java编写，位于jdk.internnal.loader.ClassLoaders类中
  >
  >    Java中的BootClassLoader即成BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。
  >
  >    **Bootstrap ClassLoader依然无法通过java代码获取到，返回的仍然是null，为了保持统一。**
  >
  >    ![image-20240115144346647](./img/74.png)
  >
  > 2. Extension ClassLoader 被替换成Platform Class Loader ，Platform ClassLoader遵循模块化的方式加载字节码文件，所以继承关系从URLClassLoader变成了 BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。**Platform Class Loader存在的更多的是与老版本的设计方案兼容，自身没有特殊的逻辑。**
  >
  >    ![image-20240115144708005](./img/75.png)

- 有几种加载器？

  > 1. 启动类加载器(Bootstrap ClassLoader) 加载核心类
  > 2. 扩展类加载器 (Extension ClassLoader) 加载扩展类
  > 3. 应用程序类加载器 (Application ClassLoader) 加载应用classpath中的类
  > 4. 自定义类加载器，重写findClass方法
  > 5. JDK9及之后扩展类加载器(Extension ClassLoader) 变成了平台类加载器(Platform ClassLoader)

  > **JDK8** 
  >
  > ![image-20240115144925651](./img/76.png)
  > 

  

---



##  3.JVM的内存区域

> 就是运行时数据区域（JVM管理的内存）
>
> ![image-20240114202018548](./img/77.png)

主要分为四部分

- 程序计数器
- 栈
- 堆
- 方法区
- **直接内存（不属于JVM管理的）**



### 运行时数据区

- Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区
- 《Java虚拟机规范》中规范了每一部分的作用。

![image-20240115171340438](./img/78.png)





#### 1）程序计数器-Program Counter

- 程序计数器（Program Counter Register ）也叫PC寄存器，每个线程会通过程序计数器**记录当前要执行的字节码指令的地址**

  > ![image-20240115172103211](./img/79.png)

  

- 在代码执行过程中，程序计数器**会记录下一行字节码指令的地址**。执行完当前指令之后，虚拟机的执行引擎会根据**程序计数器**执行下一行指令。

**案例：**

![image-20240115172549040](./img/80.png)

![image-20240115172628629](./img/82.png)

> 🌟🌟**程序计数器会记住下一行偏移量的内存地址，执行完当前指令的时候，可以根据地址找到下一行指令。**

- 在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU**切换前解释执行到那一句指令**并继续运行

  > 先执行线程A，启动一个多线程执行线程B（那么A线程的程序计数器就会记录当前A所执行的内存地址或者说偏移量），那么当A等待的时候，B执行完的时候，开始执行A了，那么A线程就会称程序计数器中找到内存地址继续执行。
  >
  > ![image-20240115194819932](./img/81.png)





**问题：**

程序计数器在运行中会出现内存溢出吗？

- 内存溢出指的是程序在使用某一块内存区域的时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限
- 因为每个线程只存储一个固定长度的内存地址，**程序计数器是不会发生内存溢出的。**
- 程序员无需对程序计数器做任何处理







#### 2）栈-Stack

Java虚拟机栈（Java Virtual Machine Stack）采用**栈的数据结构来管理调用中的基本数据**，**先进后出**（first in last out），每一个方法的调用使用一个栈帧来（Stack Frame）来保存。

![image-20240115204105545](./img/83.png)

**使用IDEA来debug的时候，打断点可以查看对应的栈帧**

![image-20240115204327960](./img/84.png)

**当抛出一个异常的时候，也会一个个退出栈帧。日志中会显示。**

![image-20240115204546036](./img/85.png)



- **Java虚拟机栈随着线程创建而创建，而回收则会在线程的销毁时进行**。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。

  > ![image-20240115213826204](./img/86.png)



**栈帧的组成**

- **局部变量表**

  > 局部变量表的作用是在运行过程中**存放所有的局部变量**

- **操作数栈**

  > 操作数栈时栈帧中虚拟机在执行指令过程中用来**存放临时数据**的一块区域

- **帧数据**

  > 帧数据主要包含动态链接、方法出口、异常表的引用



###### 局部变量表

- 局部变量表的作用是在方法执行过程存放所有的局部变量。编译成字节码文件时就可以确定局部变量表的内容

  > ```java
  > public static void test() {
  >         int i = 0;
  >         int j = 1;
  >     }
  > ```
  >
  > 字节码指令：
  >
  > ```bytecode
  > 0 iconst_0
  > 1 istore_0
  > 2 iconst_1
  > 3 istore_1
  > 4 return
  > ```
  >
  > ![image-20240115215016115](./img/87.png)
  >
  > Strat PC 从第第一行开始例如 i=0 那么就是**1 istore_0**

- 栈帧中的局部变量表是一个数组，**数组中每一个位置称之为槽（slot）**，***Long*和*Double*类型占用两个槽**，其他类型占用一个槽。

  > Code:
  >
  > ```java
  >  public static void test() {
  >         int i = 0;
  >         long j = 1;
  >         int k = 2;
  >     }
  > ```
  >
  > ![222](./img/88.png)
  >
  > 

**为什么不能在静态方法中使用this？**

> 🌟‼️**如果该方法是static的，那么不能在该方法中使用this，因为this代表实例对象，那么static随着类加载而加载，先于实例之前就创建了，不存在局部变量表中，所以不能使用**	



- 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致

- 局部变量表保存的内容有：**实例方法的this对象永远在第一位**，方法的参数，方法体中声明的局部变量。

  > ![image-20240115221651156](./img/89.png)

- 为了节省空间，局部**变量表中的槽是可以复用的**，一旦某个局部变量不再生效，当前槽就可以再次被使用

  > ```
  >  0 iconst_0
  >  1 istore_3
  >  2 iconst_1
  >  3 istore 4
  >  5 iconst_1
  >  6 istore_3
  >  7 iconst_0
  >  8 istore_3
  >  9 iconst_1
  > 10 istore 4
  > 12 return
  > ```
  >
  > ![image-20240115222933173](./img/92.png)
  >
  > **局部变量表**
  >
  > | this | k    | m    | 第一次存a、第二次的时候存了c | 第一次存b 第二次存了i | j    |
  > | ---- | ---- | ---- | ---------------------------- | --------------------- | ---- |
  > | 0    | 1    | 2    | 3                            | 4                     | 5    |



###### **操作数栈**

- 操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。

- 在**编译期**就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。

  > ![image-20240115224125924](./img/90.png)
  >
  > ```
  > 0 iconst_0
  > 1 istore_3
  > 2 iload_3
  > 3 iconst_1
  > 4 iadd
  > 5 istore 4
  > 7 return
  > ```
  >
  > ![image-20240115224442814](./img/91.png)
  >
  > > 先入栈为0 ，然后在入栈1 然后操作数栈直接相加变成1，然后在存储局部变量表中j为1
  >



###### 帧数据

> 包含了三部分：
>
> 1. 动态链接
> 2. 方法出口
> 3. 异常表

- **动态链接**  当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换对应的运行时常量池中的内存地址。**动态链接就保存了编号到常量池的内存地址的映射关系。**

  > ![image-20240116111155940](./img/93.png)
  >
  > A类调用B类的方法
  >
  > ![image-20240116111412111](./img/94.png)

- **方法出口**指的是方法在正确或者异常结束的时候。当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，**需要存储此方法出口的地址。**

  > ![image-20240116111638106](./img/95.png)

- **异常表存**放的是**代码中异常的处理信息**，包含了try代码块和catch代码块执行后跳转到到字节码指令位置

  > **Code:**
  >
  > ```java
  >  public void test() {
  >         try {
  >             int i = 0;
  >         } catch (Exception e) {
  >             int j = 1;
  >         } finally {
  >             int i = 2;
  >         }
  >     }
  > ```
  >
  > **字节码：**
  >
  > ```java
  >  0 iconst_0
  >  1 istore_1
  >  2 iconst_2
  >  3 istore_1
  >  4 goto 21 (+17)
  >  7 astore_1
  >  8 iconst_1
  >  9 istore_2
  > 10 iconst_2
  > 11 istore_1
  > 12 goto 21 (+9)
  > 15 astore_3
  > 16 iconst_2
  > 17 istore 4
  > 19 aload_3
  > 20 athrow
  > 21 return
  > ```
  >
  > 异常的时候， **7 astore_1**
  >
  > ![image-20240116112027389](./img/96.png)



###### 栈内存溢出

- Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配到最大大小就会出现内存溢出。

- Java虚拟机栈内存溢出时会初选StackOverFlowError到错误

  > **模拟栈内存溢出**
  >
  > ```java
  > public class Demo1 {
  >     private static AtomicInteger atomicInteger = new AtomicInteger();
  >     public static void main(String[] args) {
  >         test();
  >     }
  >     public static void test() {
  >         System.out.println(atomicInteger.incrementAndGet());
  >         test();
  >     }
  > }
  > ```
  >
  > **溢出报错**
  >
  > ![image-20240116114043441](./img/97.png)

- 如果我们不指定虚拟机栈的大小，JVM将创建一个具有**默认大小的栈**。大小取决于操作系统和计算机的体系结构。

  > ![image-20240116120758896](./img/98.png)
  >
  > ![image-20240116120808465](./img/99.png)
  >
  
  - ***修改Java虚拟机栈的大小***
  
  > - **要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss**
  > - **语法：**-Xss栈大小
  > - 单位：字节（默认，必须时1024的倍数），k或者K（KB），m或者M（MB），g或者G（GB）
  >
  > 案例：
  >
  > ![image-20240116121201155](./img/100.png)
  >
  > ![image-20240116121352005](./img/101.png)

**🌟🌟Tips：**

1. 与-Xss类似，也可以使用-XX:ThreadStackSize调整标志来配置堆栈大小，格式-XX:ThreadStackSize=1024

2. HotSpot JVM对栈大小的最大值和最小值有要求：

   > 比如测试如下两个参数 -Xss1k     -Xss1025m。  Windows（64）下的JDK8测试下最小值为180k，最大值为1024m

3. 局部变量过多、操作数栈深度过大也会影响栈内存的大小

   > 一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为-Xss256k节省内存



###### **本地方法栈**

- Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是**native本地方法的栈帧。**

- 在Hotspot虚拟机中，**Java虚拟机栈和本地方法栈实现使用了同一个栈空间。**本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数 同时方便出现异常时也把本地方法的栈信息打印出来。

  > ![image-20240116132525420](./img/102.png)





#### 3）堆-Heap

- 一般Java程序中堆内存是空间最大的一块内存区域。**创建出来的对象都存于堆上。****是线程共享的。**

- 栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。

  > ![image-20240116224330000](./img/103.png)



##### **模拟Heap 内存溢出**

> 当heap内存达到上限的时候，就会**OutOfMemoryError**
>
> ![image-20240116224756337](./img/104.png)

- Heap Space有个三个需要关注的值，**used、total、max**

  > **used**指的是当前已使用的堆内存，**total**是Java虚拟机已经分配的可用堆内存，**max**是Java虚拟机可以分配的最大内存。
  >
  > ![image-20240116225034573](./img/105.png)

- 随着堆中对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存空间给堆。

  > ![image-20240116225207282](./img/106.png)

- 如果heap呢存不足，Java虚拟机就会不断的分配内存，total值会变大。total最多只能与max相等。

  > ![image-20240116225318963](./img/107.png)

**Arthas观察内存变化**

> dashboard -i 2000
>
> 发现usage逐渐增加 直至崩溃
>
> ![image-20240116231500344](./img/108.png)

**问题：**

是不是当used=max=total的时候，堆内存就溢出？

> 不是，堆内存溢出的判断条件比较复杂

- Heap设置大小

  > 要修改heap的大小，可以使用虚拟机参数 **-Xmx（max最大值）和-Xms（初始的total）**
  >
  > - 单位：字节（默认，必须时1024的倍数），k或者K（KB），m或者M（MB），g或者G（GB）
  > - 限制Xmx必须大于 2MB，Xms必须大于1MB
  >
  > 
  >
  > JVM参数：
  >
  > ![image-20240116233023924](./img/109.png)
  >
  > Arthas的dashboard：
  >
  > ![image-20240116232932649](./img/110.png)

  

  **问题？**

  为什么arthas中显示的heap堆大小与设置的值不一样呢?

  > arthas中的heap堆内存使用了JMX技术中内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。

- Java服务端程序开发时，**建议将-Xmx和-Xms设置为相同的值**，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。

  > ![image-20240116233233354](./img/111.png)



#### 4）方法区-Method Area

方法区是存放**基础信息的位置，是线程共享的**，主要包含三部分内容：

- **类的元信息**--保存了所有类的基本信息
- **运行时常量池**--保存了字节码文件中的常量池内容
- **字符串常量池**--保存了字符串常量池



###### 类的元信息

- 方法区是用来存储**每个类的基本信息（元信息）**，一般称之为InstanceKlass对象。在类的**加载阶段**完成。

  > ![image-20240117103656855](./img/112.png)



###### 运行时常量池

- 方法区除了存储类的元信息之外，还存放了运行时常量池。**常量池中存放的是字节码中的常量池内容。**

- 字节码文件中通过编号查表的方法找到常量，这种常量池称为**静态常量池**。当量池加载内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为**运行时常量池**。

  > ![image-20240117104014538](./img/113.png)

- 方法区是《Java虚拟机规范》中设计的虚拟概念，每款Java虚拟机在实现上都各不相同。Hotspot设计如下：

  - JDK7之前的版本将方法区存放在堆区域中的永久代空间，堆堆大小由虚拟机参数来控制。
  - JDK8之后的版本将方法区存放在**元空间**中，元空间位于操作系统维护的直接内存中，默认情况下只要不超越操作系统承受的上限，可以一直分配。

  ![image-20240117104701920](./img/114.png)



**arthas查看方法区内存**

> JDK7:
>
> ![image-20240117105142641](./img/115.png)
>
> JDK8:
>
> ![image-20240117105306740](./img/116.png)



**验证方法区溢出**

通过ByteBuddy框架，动态生成字节码数据，加载到内存中。通过死循环不停地加载到方法区，观察方法区是否会出现内存溢出的情况。分别在JDK7和JDK8上运行上述代码。

> ```xml
>  <dependency>
>             <groupId>net.bytebuddy</groupId>
>             <artifactId>byte-buddy</artifactId>
>         </dependency>
> ```
>
> Code:
>
> ```java
> public static void main(String[] args) throws IOException {
>         System.in.read();
>         Demo1 demo1 = new Demo1();
>         int count = 0;
>         while (true) {
>             String name = "Clas" + count;
>             ClassWriter classWriter = new ClassWriter(0);
>             classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, name, null, "java/lang/Object", null);
>             byte[] byteArray = classWriter.toByteArray();
>             demo1.defineClass(name, byteArray, 0, byteArray.length);
>             System.out.println(++count);
>         }
>     }
> ```
>
> 实验发现，JDK7上运行大概十几万次，就出现了错误。在JDK8上运行百万次，程序都没有出现任何错误，但是内存会直线升高。这说明JDK7和JDK8在方法区的存放上，采用了不同的设计。
>
> - JDK7将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数-XX:MaxPermsize=值来控制
>
> - **JDK8将方法区存放在元空间中**，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用**-XX:MaxMetaspacesize=**值将元空间最大大小进行限制
>
>   >设置方法区内存大小
>   >
>   >![image-20240117110509835](./img/117.png)
>   >
>   >![image-20240117110550581](./img/118.png)



###### 字符串常量池（StringTable）

- 方法区中除了类的元信息、运行时常量池之外，还有一块区域叫**字符串常量池（StringTable）**

- 字符串常量池存储在代码中定义的**常量字符串内容**。比如“123”这个123就会被放到字符串常量池中。

  > ```java
  > public static void main(String[] args) {
  >     // heap内存中
  >     String string = new String("123");
  >     // 字符串常量池
  >     String string1 ="123";
  >     // false
  >     System.out.println(string1==string);
  >     // true 比较的是值
  >     System.out.println(string1.equals(string));
  > }
  > ```
  >
  > 

**问题：**

**字符串常量池和运行时常量池有什么关系？**

> 早期设计时，字符串常量池时属于运行时常量池池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。
>
> ![image-20240117115219941](./img/119.png)



**面试题：**

**案例1 ：**

> Code：
>
> ```java
> public static void main(String[] args) {
>         // 字符串常量池
>         String string1 = "123";
>         String string2 = "456";
>         String string3 = "123456";
>         String string4 = string1 + string2;
>         // false
>         System.out.println(string1 == string4);
>         // true 比较的是值
>         System.out.println(string3.equals(string4));
>     }
> ```
>
> 对应的字节码：
>
> > 从字节码内容（ **9 new #5 <java/lang/StringBuilder>**）可以看到 字符串相加，**底层是new了一个StringBuilder，然后调用了append方法的**
> >
> > 所以相加的字符串是一个new出来的对象存在**Heap内存**中的
> >
> > 而String string3 = "123456";是存放在**方法区的字符串常量池中**的。
>
> ```
>  0 ldc #2 <123>
>  2 astore_1
>  3 ldc #3 <456>
>  5 astore_2
>  6 ldc #4 <123456>
>  8 astore_3
>  9 new #5 <java/lang/StringBuilder>
> 12 dup
> 13 invokespecial #6 <java/lang/StringBuilder.<init> : ()V>
> 16 aload_1
> 17 invokevirtual #7 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
> 20 aload_2
> ```

**案例2：**

> 通过字节码指令分析如下代码的运行结果：
>
> ```java
>  public static void main(String[] args) {
>         // 字符串常量池
>         String string3 = "123456";
>         String string4 = "123" + "456";
>         // true 常量，在编译的时候就直接连接
>         System.out.println(string3 == string4);
>     }
> ```
>
> 字节码：
>
> ```
>  0 ldc #2 <123456>
>  2 astore_1
>  3 ldc #2 <123456>
>  5 astore_2
>  6 getstatic #3 <java/lang/System.out : Ljava/io/PrintStream;>
>  9 aload_1
> 10 aload_2
> 11 if_acmpne 18 (+7)
> 14 iconst_1
> 15 goto 19 (+4)
> 18 iconst_0
> 19 invokevirtual #4 <java/io/PrintStream.println : (Z)V>
> 22 return
> ```
>
> **都是存在Method Area中的字符串常量池中。**



###### **Intern学习**

- **String.intern()方法是可以手动将字符串放到常量池中**

  > JDK7以后
  >
  > ```java
  >   public static void main(String[] args) {
  >         String s1 = new StringBuilder().append("think").append("123").toString();
  >         // 会把对象的引用放到常量池里面
  >         System.out.println(s1.intern() == s1);
  >         // 内存中有这个关键字是Java
  >         String s2 = new StringBuilder().append("ja").append("va").toString();
  >         System.out.println(s2.intern() == s2);
  >     }
  > ```
  >
  > JDK6的结果是false、false，JDK8中是true、false（内存中有这个关键字是Java导致不相等）
  >
  > > JDK7及之后的版本出由于字符串常量池在堆上，所以**intern() **方法会把第一次遇到的字符串的引用放到字符串常量池中
  > >
  > > **7以后的版本 intern方法保存的是对象的引用**
  > >
  > > ![image-20240117140929063](./img/126.png)

问题

静态变量存在哪里？

- JDK6及之前的版本中，静态变量时存放在方法区中，也就是永久代

  > ![image-20240117141748558](./img/125.png)

- JDK7及之后的版本中，静态变量时存放Heap中的Class对象中，脱离了永久代。

  > ![image-20240117141853600](./img/120.png)



#### 5）直接内存（不属于JVM）

- 直接内存（Direct Memory）并不再《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。在JDK1.4中引入了NIO机制，使用了直接内存，主要是为了解决以下两个问题：

  1. Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。
  2. IO操作比如读文件，需要先把文件读入直接内存（缓冲区Buffer）再把数据赋值到Java堆中。现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据赋值的开销。写文件也是类似的思路。

  ![image-20240117143809403](./img/121.png)

使用直接内存：

> ```java
>   int size = 1024 * 1024 * 9;
>         ByteBuffer bufferAllocator = ByteBuffer.allocateDirect(size);
> ```
>
> ![image-20240117144109703](./img/122.png)

调整直接内存：

- 如果需要手动调整直接内存的大小，可以使用-XX:MaxDirectMemorySize= 大小单位k或K表示干字节，m或M表示兆字节，g或G表示干兆字节。默认不设置该参数情况下，JVM 自动选择最分配的大小。





#### **6）面试题 总结**

- Java的内存分成几部分？哪些部分会内存溢出？详细介绍一下吧

  > **程序计数器**，内存不会溢出，保存程序运行下一步所需指令**----线程独有**
  >
  > **栈Stack**，内存会溢出 保存一些栈帧数据，局部变量表**----线程独有**
  >
  > **本地方法栈**，native栈**----线程独有**
  >
  > **堆Heap**，会内存溢出，创建的对象信息都保存在堆小红**----线程共享**
  >
  > **方法区 Method Area**，内存会溢出，有字符串常量池，类的元信息，运行常量池**----线程共享**
  >
  > ![image-20240117145049704](./img/123.png)

- JDK7和JDK8在内存结构上的区别是什么？


> **JDK8是方法区和堆，JDK7是堆包含了方法区（永久代）和字符串常量池**
>
> ![image-20240117145140369](./img/124.png)



---





## 4.JVM的垃圾回收

- Java中为了简化对象的释放，引入了自动的垃圾回收 (Garbage Collection简称GC) 机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言比如C#、Python、Go都拥有自己的垃圾回收器

  > ![image-20240119115229380](./img/127.png)
  >
  > 

应用场景：

- 解决系统僵死的问题

  > 大厂的系统出现的许多系统僵死问题都与频繁的垃圾回收有关

- 性能优化

  > 对垃圾回收器进行合理的设置可以有效地提升程序的执行性能

- 高频面试题

> - 常见的垃圾回收器
> - 常见的垃圾回收算法
> - 四种引用
> - 项目中用了哪一种垃圾回收器



### 方法区的回收

- 方法区中能回收的内容主要就是不再使用的类。

判定一个类可以被卸载。需要同时满足下面三个条件：

1. **此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。**

   > ```java
   > Class<?> aClass = classLoader.loadClass("xxxxxxx.xxxx");
   >         Object o = aClass.newInstance();
   >         o=null;
   > ```

2. **加载该类的类加载器已经被回收**

   > ```java
   > ClassLoader classLoader = XXXX.class.getClassLoader();
   >         classLoader=null;
   > ```

3. **该类对应的java.lang.Class对象没有在任何地方被引用。**

   > ```java
   > 
   >         Class<?> aClass = classLoader.loadClass("xxxxxxx.xxxx");
   >         aClass =null;
   > ```

- 方法区的内存可以手动触发回收

  > - 如果需要手动触发垃圾回收，可以调用System.gc()方法
  > - 语法: System.gc()
  > - 注意事项:
  >   调用System,gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。

Tips🌟🌟：

> 开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件





### 堆回收

- 如何判断Heap上的对象可以回收？

  > Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用来，说明该对象还在使用，不允许被回收。
  >
  > ![image-20240119150043711](./img/128.png)
  >
  > 如果在main方法中最后执行a1=null，b1=null，是否能回收A和B对象呢？
  >
  > 可以回收，方法中已经没有办法使用引用区访问A和B对象来。



#### 引用计数器法和可达性分析法

##### **引用计数器法**

**引用计数法**会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

![image-20240119151425522](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240119151425522.png)

**引用计数器法的缺点-循环引用**

引用计数器法的优点是实现简单，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：

1. 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响
2. 存在循环引用问题，所谓循环循引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。

![image-20240119151920800](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240119151920800.png)

查看垃圾回收日志

- 可以使用verbose:gc参数
- 语法：-verbose:gc

![image-20240119165601130](./img/129.png)



##### 可达性分析算法

Java使用的是**可达性分析算法**来判断对象是否可以被回收。可达性分析将对象分为两类: **垃圾回收的根对象(GCRoot)**和**普通对象**，对象与对象之间存在引用关系

下图A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到某个GC Root对象是可达的，对象就不可被回收。

![image-20240119165903443](./img/130.png)

**哪些对象被称之为GC Root对象呢？**

- 线程Thread对象

- 系统类加载器加载的java.lang.Class对象

  > ![image-20240119170507556](./img/133.png)

- 监视器对象，用来保存同步锁synchronized关键字持有的对象

  > **this当前对象**
  >
  > ![image-20240119170217400](./img/131.png)

- 本地方法调用时使用的全局对象



> ![image-20240119170315846](./img/132.png)
>
> 如果把a1和b1都设置为null，那么这些都会被回收♻️



**查看GC Root**

通过arthas和eclipse Memory Analyzer (MAT) 工具可以查看GC Root，MAT具是eclipse推出的Java堆内存检测工具。具体操作步骤如下:

1. **使用arthas的heapdump命令将堆内存快照保存到本地磁盘中**

   > ![image-20240119173235485](./img/134.png)

2. **使用MAT工具打开堆内存快照文件。**

   > ![image-20240119173627808](./img/135.png)
   >
   > ![image-20240119173751222](./img/136.png)

3. **选择GC Roots功能查看所有的GC Root**

   > ![image-20240119173832544](./img/137.png)
   >
   > ![image-20240119174644893](./img/138.png)



#### 五种对象引用

可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。

##### 强引用

> 可达性算法中描述的对象引用，一般指的是强引用



##### 软引用

>  软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，**当程序内存不足时，就会将软引用中的数据进行回收。**
>
> 在JDK1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。
>
> ![image-20240120145103562](./img/140.png)

软引用的执行过程：

1. 将对象使用软引用包装起来，**new SoftReference<对象类型>(对象);**

   > ```java
   > byte[] byteArray = new byte[1024 * 1024 * 100];
   > SoftReference<byte[]> softReference = new SoftReference<>(byteArray);
   > ```

2. 内存不足时，虚拟机尝试进行垃圾回收。

3. 如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象

4. 如果依然内存不足，抛出OutOfMemory异常。

   > **设置堆最大内存为-Xms400m**

   > ```java
   > public static void main(String[] args) throws IOException {
   >         byte[] byteArray = new byte[1024 * 1024 * 100];
   >         SoftReference<byte[]> softReference = new SoftReference<>(byteArray);
   >         byteArray = null;
   >         // 输出一个对象
   >         System.out.println(softReference.get());
   >         System.in.read();
   >         byte[] bytes1 = new byte[1024 * 1024 * 200];
   >         SoftReference<byte[]> softReference1 = new SoftReference<byte[]>(bytes1);
   >         // 输出null
   >         System.out.println(softReference.get());
   >     }
   > ```

> 执行结果：
>
> ![image-20240120152606910](./img/141.png)

软引用中的对象如果在内存不足时回收，**SoftReference对象本身也需要被回收**。如何知道哪些SoftReference对象需要回收呢?

**SoftReference**提供了一套队列机制：

1. 软引用创建时，通过构造器传入引用队列

2. 在软引用中包含的对象被回收时，该软引用对象会被放入引用队列中

   > ![image-20240120153156957](./img/142.png)

3. 通过代码便利引用队列，将SoftReference的强引用删除

   > **设置堆内存为200m 最大能存放一个100m的byte数组**

   > ```java
   > public static void main(String[] args) throws IOException {
   >     ReferenceQueue<byte[]> referenceQueue = new ReferenceQueue<>();
   >     ArrayList<SoftReference<byte[]>> softReferences = new ArrayList<>();
   >     for (int i = 0; i < 10; i++) {
   >         byte[] byteArray = new byte[1024 * 1024 * 100];
   >         SoftReference<byte[]> softReference = new SoftReference<>(byteArray, referenceQueue);
   >         softReferences.add(softReference);
   >     }
   >     System.in.read();
   >     int count = 0;
   >     while (referenceQueue.poll() != null) {
   >         count++;
   >     }
   >     System.out.println(count);
   > }
   > ```

> 最终打印的结果为9，每一次释放软引用内存，然后在重新新增一个进去，循环十次，那么最终空的软应用对象为9个，其中一个还没释放内存，软引用对象还是强引用。

软应用也可以使用继承自SoftReference类的方式来实现，StudentRef类就是一个软引用。通过构造器传入软引用包含的对象，已经引用队列。

> ```java
> class StringRef extends SoftReference<String>{
> 
>     public StringRef(String referent) {
>         super(referent);
>     }
>     public StringRef(String referent, ReferenceQueue<? super String> q) {
>         super(referent, q);
>     }
> }
> ```



![image-20240119212936727](./img/143.png)

 



##### 弱引用

> 弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不**管内存够不够都会直接被回收。**
>
> 在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。
>
> 弱引用对象本身也可以使用引用队列进行回收
>
> ![image-20240120155733983](./img/144.png)

> 设置堆最大内存为200m
>
> ```java
> public static void main(String[] args) throws IOException {
>         byte[] byteArray = new byte[1024 * 1024 * 100];
>         WeakReference<byte[]> reference = new WeakReference<>(byteArray);
>         byteArray = null;
>         System.out.println(reference.get());
>         System.gc();
>         System.out.println(reference.get());
>     }
> ```



##### 虚引用

在常规开发中是不会使用的

> **虚引用**也叫**幽灵引用/幻影引用**，**不能通过虚引用对象获取到包含的对象**。**虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知**。Java中使用**PhantomReference**实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。



##### 终结器引用

在常规开发中是不会使用的

> 终结器引用指的是在对象需要被回收时，**对象将会被放置在Finalizer类中的引用队列中，并在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法**。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。
>
> ![image-20240120160411737](./img/145.png)

---





#### 垃圾回收算法

- Java是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事情：
  1. 找到内存中存活的对象
  2. 释放不再存活对象的内存，使得程序能再次利用这部分空间



##### 历史和分类

- 1960年John McCarthy发布了第一个GC算法: **标记-清除算法**

- 1963年Marvin L.Minsky 发布了**复制算法**。

  > 本质上后续所有的垃圾回收算法，都是在上述两种算法的基础上优化而来。
  >
  > ![image-20240120161012027](/Users/gaoshang/Library/Application Support/typora-user-images/image-20240120161012027.png)



##### 垃圾回收算法的评价标准

> Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为**Stop The World**简称**STW**，如果STW时间过长则会影响用户的使用。
>
> ![image-20240120161301749](./img/146.png)

判断GC算法是否优秀，可以从三个方面来考虑：

- **吞吐量TPS**

  > 吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即**吞吐量 = 执行用户代码时间(执行用户代码时间 + GC时间)**。吞吐量数值越高，垃圾回收的效率就越高。
  >
  > 比如: 虚拟机总共运行了 100 分钟，其中GC花掉 1 分钟，那么吞吐量就是 99%

- **最大暂停时间**

  > 最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。比如如下的图中，黄色部分的STW就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。
  >
  > ![image-20240120162000469](./img/147.png)

- **堆使用效率**

  > 不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法.
  >
  > ![image-20240120162103273](./img/148.png)

**总结：**

> 上述三种评价标准:堆使用效率、吞吐量，以及最大暂停时间不可兼得般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量.
>
> **不同的垃圾回收算法，适用于不同的场景**





##### 标记清除算法

标记清除算法的核心思想分为两个阶段：

1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。
2. 清除阶段，从内存中删除没有被标记也就是非存活对象。

**优点：**

> 实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可.

**缺点：**

> 1. **碎片化问题**
>
>    > 由于**内存是连续的**，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是个比较大的空间，很有可能这些内存单元的大小过小无法进行分配
>    >
>    > ![image-20240120163146951](./img/150.png)
>    >
>    > ![image-20240120163159483](./img/149.png)
>
> 2. 分配速度慢。
>
>    > 由于内存碎片的存在，需要维护一个**空闲链表**，**极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间**。
>    >
>    > ![image-20240120163322369](./img/151.png)



##### 复制算法

核心思想为：

1. 准备两块空间From空间和To空间，每次在分配对象阶段，只能使用其中一块空间（From空间）。
2. 在垃圾回收GC阶段，将From中存活对象复制到To空间。
3. 将两块空间的From和To名字互换。

**完整的复制算法的例子：**

1. 将堆内存分割成两块**From空间、To空间**，对象分配阶段，创建对象。

2. GC阶段开始，**将GC Root搬运到To空间**

3. 将**GC Root关联的对象，搬运到To空间**

4. **清理From空间**，并把名称互换

   > ![image-20240120163745591](./img/152.png)

**优点：**

> 1. **吞吐量高**
>
>    > 复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，**但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动**
>
> 2. **不会发生碎片化**
>
>    > 复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

**缺点：**

> **内存使用效率低**
>
> > 每次只能让一半的内存空间来为创建对象使用



##### 标记整理（压缩）算法

> 标记整理算法也叫标记压缩算法，**是对标记清理算法中容易产生内存碎片问题的一种解决方案**

核心思想分为两个阶段：

1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。

2. 整理阶段，**将存活对象移动到堆的一端**。清理掉存活对象的内存空间。

   > ![image-20240120164243224](./img/153.png)
   >
   > **那么就会多出来一块完整的内存区域--红色部分**
   >
   > ![image-20240119225913079](./img/154.png)



**优点：**

> 1. **内存使用效率高**
>
>    > 整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
>
> 2. **不会发生碎片化**
>
>    > 在整理阶段可以将对象往内存的一侧进行移动，**剩下的空间都是可以分配对象的有效空间**

缺点：

> **整理阶段的效率不高**
>
> > 整理算法有很多种，比如***Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。***可以通过Two-Finger、表格算法、ImmixGc等高效的整理算法优化此阶段的性能
>
> 



##### 分代垃圾回收算法

> 现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法（Generation GC）。

分代垃圾回收算法将整个内存区域划分为**年轻代**和**老年代**：

![image-20240120164845048](./img/155.png)



**使用Arthas查看分代之后的内存情况**

- 在JDK8中，添加**-xx:+UseSerialGC**参数使用分代回收的垃圾回收器，运行程序

- 使用memory命令查看内存情况

  > ![image-20240120165148349](./img/156.png)

**调整内存区域的大小**

根据以下虚拟机参数，调整堆的大小并观察结果。注意加上**-XX:UseSerialGC（串行垃圾回收器）**

|                 参数名                  |                           参数含义                           |                             示例                             |
| :-------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|                  -Xms                   |       设置堆的最小和初始大小，必须是1024倍数且大于1MB        | 比如初始大小6MB的写法Xms6291456<br/>Xms6144k<br/>-Xms6m<br/> |
|                  -Xmx                   |        设置最大堆的大小，必须是1024倍数且大于2MB<br/>        | 比如最大堆80 MB的写法:<br/>-Xmx83886080<br/>-Xmx81920k<br/>-Xmx80m<br/> |
|                  -Xmn                   |                      新生代的大小<br/>                       | 新生代256 MB的写法:-Xmn256m<br/>Xmn262144k<br/>-Xmn268435456<br/> |
|         -XX:SurvivorRatio<br/>          | 伊甸园区和幸存区的比例，默认为8<br/>新生代1g内存，伊甸园区800MB,S0和S1各100MB<br/> |        比例调整为4的写法:<br/>XX:SurvivorRatio=4<br/>        |
| -XX:+PrintGcDetails<br/>verbose:gc<br/> |                       打印GC日志<br/>                        |                              无                              |

> 观察GC变化
>
> ```java
>  // --XX:+PrintGcDetails  -Xmx60m -Xms60M -XX:+UseSerialGC -XX:SurvivorRatio=3 -Xmn20M
>     public static void main(String[] args) throws IOException {
>         ArrayList<Object> objects = new ArrayList<>();
>         int count = 0;
>         while (true) {
>             System.in.read();
>             byte[] byteArray = new byte[1024 * 1024 * 10];
>             System.out.println(count);
>             objects.add(byteArray);
>             count++;
>         }
>     }
> 
> ```
>
> ```
> Heap
>  def new generation   total 16384K, used 11364K [0x00000007bc400000, 0x00000007bd800000, 0x00000007bd800000)
>   eden space 12288K,  92% used [0x00000007bc400000, 0x00000007bcf19108, 0x00000007bd000000)
>   from space 4096K,   0% used [0x00000007bd000000, 0x00000007bd000000, 0x00000007bd400000)
>   to   space 4096K,   0% used [0x00000007bd400000, 0x00000007bd400000, 0x00000007bd800000)
>  tenured generation   total 40960K, used 30720K [0x00000007bd800000, 0x00000007c0000000, 0x00000007c0000000)
>    the space 40960K,  75% used [0x00000007bd800000, 0x00000007bf600030, 0x00000007bf600200, 0x00000007c0000000)
>  Metaspace       used 3291K, capacity 4496K, committed 4864K, reserved 1056768K
>   class space    used 362K, capacity 388K, committed 512K, reserved 1048576K
> ```
>
> 

**分代GC流程**

- 分代回收算法回收时，创建出来的对象首先会被放入Eden伊甸园区。

> ![image-20240120174126414](./img/157.png)

- 随着对象在Eden区越来越多，如果Eden区满了，新创建的对象已经无法放入，就会触发年轻代的GC，称之为Minor GC或者YoungGC。Minor GC会把需要eden中和From需要回收的对象回收，**把没有回收的对象放入To区**

> ![image-20240120174353932](./img/158.png)

- 接下来 S0区会变成To区，S1变成From区。当eden区满是再往里放入对象，依然会发生Minor GC。

![image-20240120174644172](./img/159.png)

- 此时会回收eden区和S1（from）中的对象，并把eden和from区中剩余的对象放入S0.

- 注意：每次MinorGC后都会为对象寄了他的年龄，初始值为0，每次GC完加1.

- 如果MinorGC后对象的年龄达到阀值（最大15，默认值和垃圾回收器有关，有时候当young区满了之后，不满15次也会放入Old区），对象就会被晋升至老年代。

> ![image-20240120175015382](./img/160.png)

- 当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收

> ![image-20240120175049694](./img/161.png)
>
> ![image-20240120175116465](./img/162.png)



**下图为什么会出现OutOf Memory？**

![image-20240120175203293](./img/163.png)

> Full GC后。无法回收老年代**99.93%**，那么继续往Old 区放数据，那么就会抛异常。





#### 垃圾回收器

**为什么GC算法要把Heap分成年轻代和老年代？**

> - 系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，如果查询某某数据，数据返回之后就可以释放了。
> - 老年代中会存放长期存活的对象，比如Spring的大部分Bean对象，在程序启动之后就不会被回收了。
> - 在虚拟机的默认设置中，新生代的大小要远小于老年代的大小。
>
> 1. 可以通过调整Young区域和Old区的比例来适用不同类型的应用程序，提高内存的利用效率和性能
> 2. Young区和Old区使用不同的垃圾回收算法。Young区一般使用复制算法，老年代可以选择-标记和清除-整理算法，由程序员来选择的灵活度较高
> 3. 分代的设计中允许只回收Young区（Minor GC），如果能满足对象分配的要求就不需要对整个堆进行回收（Full GC），STW占用的时间就会减少。
>
> ![image-20240122125911330](./img/164.png)



---



##### 垃圾回收器的组合

垃圾回收器是垃圾回收算法的具体实现。

由于垃圾回收器分为Young区和Old区，出了G1之外其他垃圾回收器必须成对组合进行使用。

具体的关系图：

> 只推荐使用实线连接的
>
> ![image-20240122130537756](./img/165.png)



###### 年轻代-Serial垃圾回收器

>  Serial是一种**单线程串行**的垃圾回收器
>
> ![image-20240122130923169](./img/166.png)
>
> 回收年代：年轻代
>
> 回收算法：复制算法
>
> 优点：单CPU处理器下吞吐量非常出色
>
> 缺点：多CPU下吞吐量不如其他垃圾回收器，Heap如果偏大，会让用户线程处于长时间的等待
>
> 使用场景：Java编写的客户端程序或者硬件配置有限的场景



###### 老年代-SerialOld垃圾回收器

> SerialOld是Serial垃圾回收器的老年代版本，采用**单线程串行回收**，**-XX:+UseSerialGC 新生代、老年代都适用串行回收器**
>
> ![image-20240122131605767](./img/167.png)
>
> 回收年代：老年代
>
> 回收算法：复制算法
>
> 优点：单CPU处理器下吞吐量非常出色
>
> 缺点：多CPU下吞吐量不如其他垃圾回收器，Heap如果偏大，会让用户线程处于长时间的等待
>
> 使用场景：与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用







###### 年轻代-ParNew垃圾回收器

>**ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收**
>
>**-XX:+UseParNewGC Young区使用ParNew回收器，老年代使用SerialOld回收器**
>
>![image-20240122132019645](./img/168.png)
>
>回收年代：年轻代
>
>回收算法：复制算法
>
>优点：多CPU处理器下停顿时间较短
>
>缺点：吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用
>
>使用场景：JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用



###### 老年代-CMS(Concurrent Mark Sweep)垃圾回收器

> CMS垃圾回收器关注的是系统的**暂停时间**，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间
>
> ![image-20240122132321936](./img/169.png)
>
> 参数：XX:+UseConcMarkSweepGC
>
> 回收年代：年轻代
>
> 回收算法：标记清除算法
>
> 优点：系统由于垃圾回收出现的停顿时间较短，用户体验好
>
> 缺点：1. 内存碎片问题 2. 退化问题 3. 浮动垃圾问题
>
> 使用场景：大型的互联网系统中请求数据量大，频率高的场景，比如订单接口、商品接口等
>
> **🌟CMS执行步骤：**
>
> 1. 初始标记，用极短的时间标记处GC Roots能直接关联的对象。
> 2. 并发标记，标记所有的对象，用户线程不需要暂停
> 3. 重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。
> 4. 并发清理，清理死亡的对象，用户线程不需要暂停。
>
> ![image-20240122133103265](./img/170.png)
>
> 缺点：
>
> 1. CMS使用了标记-清除算法，在垃圾回收结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0） 调整N次Full 之后再整理。
>
> 2. 无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。
>
> 3. 如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。
>
>    ![image-20240122133925447](./img/171.png)



###### 年轻代- Parallel Scavenge垃圾回收器

> Parallel Scavenge 是JDK8默认的年轻代垃圾回收器，**多线程并行回收，关注的是系统的吞吐量**。具备**自动调整堆内存大小的**特点。
>
> ![image-20240124160255636](./img/172.png)
>
> 
>
> 回收年代：年轻代
>
> 回收算法：复制算法
>
> 优点：吞吐量高，而且可以手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数
>
> 缺点：不能保证单次的停顿时间
>
> 使用场景：后台任务，不需要与用户交互，并且容易产生大量的对象，比如大数据的处理、大文件导出。



###### 老年代- Parallel Old垃圾回收器

> Parallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。
>
> ![image-20240124160656710](./img/173.png)
>
> 参数：XX:+UseConcMarkSweepGC
>
> 回收年代：老年代
>
> 回收算法：标记-整理算法
>
> 优点：并发收集，在多核CPU下效率较高
>
> 缺点：暂停时间会比较长
>
> 使用场景：与Parallel Scavenge 配套使用

Parallel Scavenge垃圾回收器

> 允许手动设置最大暂停时间和吞吐量。
>
> Oracle官方建议在使用这个组合时，**不要设置堆内存的最大值**，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小
>
> **最大暂停时间：`-XX:MaxGCPauseMillis` 设置每次垃圾回收时的最大停顿毫秒数**
>
> **吞吐量：-XX:GCTimeRatio=n 设置吞吐量为n（用户执行时间=n/n+1）**
>
> **自动调整内存大小：`-XX:+UseAdaptiveSizePolicy` 设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小**



##### G1垃圾回收器

JDK9之后默认的垃圾回收器时G1 （Garbage First）垃圾回收器。

Parallel Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用空间的大小。

CMS关注暂停时间，但是吞吐量方面会下降。

而G1设计目标就是将上述两种垃圾回收器的优点融合：

1. 支持巨大的Heap回收，并有较高的吞吐量。
2. 支持多CPU并行垃圾回收
3. 允许用户设置最大暂停时间

**🌟JDK9之后强烈建议使用G1垃圾回收器**



###### G1-内存结构

G1的整个堆会被划分成多个大小相等的区域，称之为区**Region**，区域不要求是连续的。分为**Eden**、**Survivor**、**Old区**。Region的大小通过堆空间大小/2048计算得到，也可以通过参数**-XX:G1HeapRegionSize=32m**指定(其中32m指定region大小为32M)，**Region size必须是2的指数幕，取值范围从1M到32M。**

<img src="./img/174.png" alt="image-20240124215912333" style="zoom:50%;" />

G1垃圾回收方式：

- **年轻代回收（Young GC）**
- **混合回收（Mixed GC）**



###### G1-年轻代回收

- 年轻代回收（Young GC），回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数-XX:MaxGCPauseMillis=n（默认为200）设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。

- **执行流程：**

  > 1. 新创建的对象会存放在Eden区。当G1判断年轻代区不足（Max默认为60%），无法分配对象时需要回收时会执行Young GC
  > 2. 标记出Eden和Survivor区域中的存活对象
  > 3. 根据配置的最大暂停时间**选择某些区域存活对象复制到一个新的Survivor区中（年龄+1）**，清空这些区域。
  >
  > <img src="./img/175.png" alt="image-20240124220616969" style="zoom: 25%;" /><img src="./img/176.png" alt="image-20240124220641313" style="zoom: 25%;" />

> G1在进行Young GC到过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。
>
> 比如：-XX:MaxGCPauseMillis=n（默认200） 每个Region回收耗时40ms，那么每次回收最多只能回收4个Region。
>
> <img src="./img/177.png" alt="image-20240124221610205" style="zoom:50%;" />
>
> 4. 后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。
>
> <img src="./img/178.png" alt="image-20240124221734240" style="zoom: 33%;" />
>
> 5. 当某个存活对象的年龄到达阀值（默认15），将被放入老年代。
>
>    <img src="./img/179.png" alt="image-20240124221921234" style="zoom:33%;" />
>
> 6. 部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为**Humongous区**。比如堆内存时4G，每个Region是2M，只要一个大对象超过1M就会被放入Humongous区，如果对象过大会横跨多个Region。
>
>    <img src="./img/180.png" alt="image-20240124222224073" style="zoom:33%;" />



###### G1-混合回收

> 7. 多次垃圾回收之后，会出现很多Old老年代区，此时总Heap占用率达到阀值时（-XX:InitiatingHeap OccupancyPercent 默认45%）会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。
>
>    <img src="./img/182.png" alt="image-20240124222700950" style="zoom:33%;" />

- **混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）**

- G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage First）名称的由来

  > ![image-20240124222948542](./img/181.png)
  >
  > ![image-20240124223035049](./img/183.png)

- 最后清理阶段使用复制算法，不会产生内存碎片

  > ![image-20240124223302635](./img/184.png)



###### G1-Full GC

注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应用的Heap有一定多余的空间。

> <img src="./img/185.png" alt="image-20240124223629239" style="zoom:50%;" />
>
> **参数1: -XX:+UseG1GC 打开G1的开关，JDK9之后默认不需要打开**
>
> **参数2: -XX:MaxGCPauseMillis=毫秒值最大暂停的时间**
>
> <img src="./img/186.png" alt="image-20240124223747007" style="zoom:50%;" />
>
> 回收年代：年轻代+老年代
>
> 回收算法：复制算法
>
> **优点：对比较大的Heap 如超过6G大Heap回收时，延迟可控，不会产生内存碎片，并发标记的SATB算法效率高**
>
> **缺点：JDK8之前还不够成熟**
>
> 使用场景：JDK8最新版本，JDK9之后建议默认使用

🌟Tips：

> 垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下:
> **JDK8及之前：**
> **ParNew + CMS (关注暂停时间) 、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1 (DK8之前不建议，较大堆并且关注暂停时间)**
> **JDK9之后:**
> **G1 (默认)**
>
> 从JDK9之后，由于G1日趋成熟，JDK默认的垃圾回收器已经修改为G1，所以强烈建议在生产环境上使用G1。
> G1的实现原理将在《原理篇》中介绍，更多前沿技术ZGC、GraalVM将在《高级篇》中介绍



1、Java中有哪几块内存需要进行垃圾回收?
2、有哪几种常见的引用类型?
3、有哪几种常见的垃圾回收算法?
4、常见的垃圾回收器有哪些?
